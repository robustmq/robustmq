
## Logo
![image](/images/robustmq-logo.png)

## 愿景

成为新一代云原生与 AI 原生消息基础设施。

## 为什么要做 RobustMQ

传统消息队列在AI时代面临新挑战：协议割裂需要维护多套系统、延迟抖动无法满足实时AI需求、存算耦合难以支持Serverless、成本高昂缺乏弹性扩缩容。

RobustMQ 应运而生，专为AI时代和云原生环境重新设计。

---

## 核心特性

**设计理念**：AI-Ready、云原生、多协议统一、存算分离、插件化存储

### 🦀 Rust 高性能内核
- 零开销抽象、内存安全、无GC停顿
- 基于Tokio异步运行时，支持百万级并发连接
- 微秒级延迟，满足实时AI应用需求

### 🔌 多协议统一平台
- **MQTT** (1883/8083) - IoT设备、实时通信
- **Kafka** (9092) - 大数据流处理、AI训练
- **AMQP** (5672) - 企业集成、微服务
- 一次部署，多协议可用

### ☁️ 存算分离架构
- **Broker Server**: 无状态协议处理，支持Serverless
- **Meta Service**: 基于Raft的高可用元数据管理
- **Journal Server**: 插件化存储，支持本地文件、S3、HDFS等

### 💾 插件化存储
- 内存存储：微秒级延迟，极致性能
- SSD存储：毫秒级延迟，高频访问
- 对象存储：秒级延迟，超低成本
- 支持WAL机制，保证一致性

---

## 发展路线

- **2025年Q4**：MQTT协议生产可用，发布0.2.0版本
- **2026年**：完善Kafka兼容性，支持AI训练数据管道
- **长期目标**：成为Apache顶级项目

---

## 核心优势

- **🚀 极致性能**：Rust零成本抽象，微秒级延迟，零GC停顿
- **🔌 多协议统一**：MQTT/Kafka/AMQP一体化，避免系统割裂
- **☁️ 存算分离**：无状态计算层，支持Serverless和弹性扩缩容
- **💾 插件化存储**：内存/SSD/对象存储智能分层
- **🎯 AI原生**：专为AI工作流优化，支持海量数据和实时推理
- **🌐 云原生**：容器化、K8s Operator、可视化管理
- **🤝 开源驱动**：Apache 2.0协议，活跃的全球社区

---

📌 **RobustMQ** —— 新一代云原生与AI原生消息基础设施

---

## 📖 了解更多

想要深入了解RobustMQ的技术细节和设计思路？阅读我们的详细博客文章：
**[用 Rust 重新定义云原生消息队列的未来](../Blogs/01.md)**
