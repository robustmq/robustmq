# RobustMQ é«˜æ€§èƒ½å­˜å‚¨å¼•æ“å®ç°æ–¹æ¡ˆ

> åŸºäºé›¶æ‹·è´æŠ€æœ¯ã€Rust æ€§èƒ½ä¼˜åŠ¿å’Œæ’ä»¶åŒ–å­˜å‚¨æ¶æ„ï¼Œè®¾è®¡ RobustMQ é«˜æ€§èƒ½å­˜å‚¨å¼•æ“çš„å®Œæ•´å®ç°æ–¹æ¡ˆã€‚

---

## ä¸€ã€è®¾è®¡ç›®æ ‡ä¸æ ¸å¿ƒç†å¿µ

### 1.1 äº”å¤§æ ¸å¿ƒåœºæ™¯éœ€æ±‚

æ ¹æ®[ã€Šå…³äº RobustMQ å­˜å‚¨å¼•æ“çš„æ€è€ƒã€‹](13.md)ï¼ŒRobustMQ éœ€è¦æ»¡è¶³äº”ç±»åœºæ™¯ï¼š

| åœºæ™¯ | æ ¸å¿ƒè¯‰æ±‚ | æ€§èƒ½æŒ‡æ ‡ | æŠ€æœ¯é€‰å‹ |
|------|---------|---------|---------|
| **ä½å»¶æ—¶ã€é«˜åå** | P99 < 10ms<br>åå > 100ä¸‡ msg/s | å»¶æ—¶ç¨³å®šæ€§ â­â­â­â­â­<br>ååé‡ â­â­â­â­â­ | Journal Engine + é›¶æ‹·è´ |
| **é«˜ååã€ä½æˆæœ¬** | æˆæœ¬é™ä½ 70%<br>PB çº§æ•°æ® | æˆæœ¬ä¼˜åŒ– â­â­â­â­â­<br>å»¶æ—¶é€‚å½“ç‰ºç‰² | å¯¹è±¡å­˜å‚¨ + æœ¬åœ°ç¼“å­˜ |
| **ç™¾ä¸‡ Topic/Partition** | æ”¯æŒ 100 ä¸‡+ åˆ†åŒº<br>å…ƒæ•°æ®è½»é‡ | åˆ†åŒºæ•° â­â­â­â­â­<br>æ€§èƒ½æƒè¡¡ â­â­â­ | å…±äº«æ–‡ä»¶ + RocksDB ç´¢å¼• |
| **æä½å»¶æ—¶ã€é«˜ QPS** | P99 < 1ms<br>QPS > 1000 ä¸‡ | å»¶æ—¶ â­â­â­â­â­<br>å…è®¸ä¸¢å¤± | å†…å­˜ + Mmap |
| **è¾¹ç¼˜æ¶ˆæ¯é˜Ÿåˆ—** | èµ„æº < 100MB<br>æ— å¤–éƒ¨ä¾èµ– | è½»é‡çº§ â­â­â­â­â­<br>é«˜å†…èš â­â­â­â­â­ | Memory/File + é›¶ä¾èµ– |

### 1.2 è®¾è®¡åŸåˆ™

**æ ¸å¿ƒåŸåˆ™**ï¼šæ’ä»¶åŒ–å­˜å‚¨ + é›¶æ‹·è´æŠ€æœ¯ + Rust æ€§èƒ½ä¼˜åŠ¿

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              RobustMQ é«˜æ€§èƒ½å­˜å‚¨è®¾è®¡ç†å¿µ                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  1. åœºæ™¯é©±åŠ¨ï¼šä¸åŒåœºæ™¯é€‰æ‹©æœ€ä¼˜æŠ€æœ¯æ ˆ                       â”‚
â”‚  2. é›¶æ‹·è´ä¼˜å…ˆï¼šæœ€å¤§åŒ–åˆ©ç”¨é›¶æ‹·è´æŠ€æœ¯                       â”‚
â”‚  3. æ··åˆæ¶æ„ï¼šå•ä¸€é›†ç¾¤æ”¯æŒå¤šç§å­˜å‚¨å¼•æ“                      â”‚
â”‚  4. æ€§èƒ½å¯é¢„æµ‹ï¼šå»¶æ—¶ç¨³å®šï¼Œæ—  GC åœé¡¿                       â”‚
â”‚  5. æˆæœ¬å¯ä¼˜åŒ–ï¼šå­˜ç®—åˆ†ç¦»ï¼Œçµæ´»é€‰æ‹©å­˜å‚¨ä»‹è´¨                  â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## äºŒã€æ€»ä½“æ¶æ„è®¾è®¡

### 2.1 å­˜å‚¨å±‚æ¶æ„å…¨æ™¯å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Broker Server (åè®®å±‚)                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ MQTT Broker â”‚ Kafka Brokerâ”‚ AMQP Broker â”‚ RocketMQ    â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚         â”‚             â”‚             â”‚             â”‚              â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                          â†“                                        â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚         â”‚      Storage Adapter (å­˜å‚¨é€‚é…å±‚)       â”‚               â”‚
â”‚         â”‚    â€¢ ç»Ÿä¸€ Shard æŠ½è±¡                    â”‚               â”‚
â”‚         â”‚    â€¢ è·¯ç”±åˆ°ä¸åŒå­˜å‚¨å¼•æ“                  â”‚               â”‚
â”‚         â”‚    â€¢ å¤šç»´åº¦æŸ¥è¯¢æ”¯æŒ                      â”‚               â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚              æ’ä»¶åŒ–å­˜å‚¨å¼•æ“å±‚ (é›¶æ‹·è´ä¼˜åŒ–)              â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚                                                     â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
    â”‚  â”‚ Memory   â”‚  â”‚ RocksDB  â”‚  â”‚  File    â”‚         â”‚
    â”‚  â”‚ æä½å»¶æ—¶  â”‚  â”‚ å•æœºæŒä¹…åŒ–â”‚  â”‚ æœ¬åœ°å­˜å‚¨ â”‚  æœ¬åœ°å­˜å‚¨ â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
    â”‚                                                     â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
    â”‚  â”‚         Journal Engine (æ ¸å¿ƒå¼•æ“)             â”‚  â”‚
    â”‚  â”‚  â€¢ io_uring å¼‚æ­¥ I/O                         â”‚  â”‚
    â”‚  â”‚  â€¢ Mmap é›¶æ‹·è´è¯»å–                            â”‚  â”‚  è¿œç¨‹å­˜å‚¨
    â”‚  â”‚  â€¢ sendfile é›¶æ‹·è´ä¼ è¾“                        â”‚  â”‚  (é›†ç¾¤)
    â”‚  â”‚  â€¢ Direct I/O WAL                            â”‚  â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
    â”‚                                                     â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
    â”‚  â”‚  MySQL   â”‚  â”‚  Redis   â”‚  â”‚ MinIO/S3 â”‚         â”‚
    â”‚  â”‚ å…³ç³»å­˜å‚¨  â”‚  â”‚ ç¼“å­˜åŠ é€Ÿ â”‚  â”‚ å¯¹è±¡å­˜å‚¨ â”‚         â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚              ç‰©ç†å­˜å‚¨å±‚ (å¤šä»‹è´¨)                       â”‚
    â”‚  â€¢ å†…å­˜ (DRAM)                                       â”‚
    â”‚  â€¢ æœ¬åœ° SSD (NVMe)                                   â”‚
    â”‚  â€¢ äº‘ç›˜ (EBS/äº‘ç¡¬ç›˜)                                  â”‚
    â”‚  â€¢ å¯¹è±¡å­˜å‚¨ (S3/OSS/MinIO)                            â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 å­˜å‚¨å¼•æ“æŠ€æœ¯é€‰å‹çŸ©é˜µ

| å­˜å‚¨å¼•æ“ | é›¶æ‹·è´æŠ€æœ¯ | æ€§èƒ½ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ | å¼€å‘ä¼˜å…ˆçº§ |
|---------|----------|---------|---------|-----------|
| **Memory** | - | P99 < 1ms<br>QPS 1000ä¸‡+ | æä½å»¶æ—¶ã€å…è®¸ä¸¢å¤± | âœ… å·²å®Œæˆ |
| **RocksDB** | Mmap (å¯é€‰) | P99 < 10ms<br>å•æœºæŒä¹…åŒ– | å¼€å‘æµ‹è¯•ã€å•æœºéƒ¨ç½² | âœ… å·²å®Œæˆ |
| **File** | Mmap + sendfile | P99 < 5ms<br>é›¶æ‹·è´è¯»å†™ | è½»é‡çº§ã€è¾¹ç¼˜è®¡ç®— | ğŸš§ è§„åˆ’ä¸­ |
| **Journal Engine** | io_uring + Mmap<br>+ sendfile + Direct I/O | P99 < 10ms<br>åå 100ä¸‡+ msg/s | æ ¸å¿ƒåœºæ™¯ï¼ˆé»˜è®¤ï¼‰ | ğŸš§ å¼€å‘ä¸­ |
| **MySQL** | - | å»¶æ—¶è¾ƒé«˜<br>å¯é æ€§å¥½ | æ¶ˆæ¯æŒä¹…åŒ–åˆ° MySQL | âœ… å·²å®Œæˆ |
| **Redis** | - | P99 < 2ms<br>å†…å­˜å­˜å‚¨ | çƒ­æ•°æ®ç¼“å­˜ | ğŸ“‹ è§„åˆ’ä¸­ |
| **MinIO/S3** | - | æˆæœ¬æœ€ä½<br>å»¶æ—¶è¾ƒé«˜ | PB çº§å­˜å‚¨ã€æˆæœ¬ä¼˜åŒ– | ğŸ“‹ è§„åˆ’ä¸­ |

---

## ä¸‰ã€æ ¸å¿ƒå­˜å‚¨å¼•æ“ï¼šJournal Engine è¯¦ç»†è®¾è®¡

### 3.1 è®¾è®¡ç›®æ ‡

**Journal Engine** æ˜¯ RobustMQ çš„æ ¸å¿ƒå­˜å‚¨å¼•æ“ï¼Œç›®æ ‡æ˜¯æ»¡è¶³ **ä½å»¶æ—¶ã€é«˜ååã€é«˜å¯é ** ä¸‰å¤§æ ¸å¿ƒéœ€æ±‚ã€‚

**æ€§èƒ½æŒ‡æ ‡**ï¼š
- P99 å»¶æ—¶ < 10ms
- P999 å»¶æ—¶ < 50ms
- å•æœºåå > 100 ä¸‡ msg/s
- æ”¯æŒæ°´å¹³æ‰©å±•ã€å¤šå‰¯æœ¬
- å¯é æ€§ 99.99%

### 3.2 æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               Journal Engine æ ¸å¿ƒæ¶æ„                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚   â”‚         å†™å…¥è·¯å¾„ (Write Path)                      â”‚    â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚
â”‚   â”‚  â”‚  1. WAL (Direct I/O)                       â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ O_DIRECT ç»•è¿‡é¡µç¼“å­˜                   â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ 4KB å¯¹é½å†™å…¥                          â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ fsync() ç¡®ä¿æŒä¹…åŒ–                    â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ P99 < 2ms                            â”‚  â”‚    â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚
â”‚   â”‚               â†“                                   â”‚    â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚
â”‚   â”‚  â”‚  2. Memory Buffer (æ‰¹é‡å†™å…¥)                â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ 256KB æ‰¹é‡ç¼“å†²åŒº                       â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ å¼‚æ­¥åˆ·ç›˜ (io_uring)                    â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ ååä¼˜åŒ–                              â”‚  â”‚    â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚
â”‚   â”‚               â†“                                   â”‚    â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚
â”‚   â”‚  â”‚  3. Segment File (åˆ†æ®µå­˜å‚¨)                 â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ æ¯ä¸ª Segment 1GB                      â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ å¤šå‰¯æœ¬å¤åˆ¶                            â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ å¯é…ç½®å‹ç¼©                            â”‚  â”‚    â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚   â”‚         è¯»å–è·¯å¾„ (Read Path)                       â”‚    â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚
â”‚   â”‚  â”‚  1. Index (RocksDB/Mmap)                   â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ Offset â†’ æ–‡ä»¶ä½ç½®                      â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ Key â†’ Offset                          â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ Tag â†’ Offset åˆ—è¡¨                      â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ Timestamp â†’ Offset                    â”‚  â”‚    â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚
â”‚   â”‚               â†“                                   â”‚    â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚
â”‚   â”‚  â”‚  2. çƒ­æ•°æ®ç¼“å­˜ (Page Cache / Mmap)          â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ æœ€è¿‘ 3 ä¸ª Segment Mmap æ˜ å°„            â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ é›¶æ‹·è´è¯»å–                            â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ P99 < 5ms                            â”‚  â”‚    â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚
â”‚   â”‚               â†“                                   â”‚    â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚
â”‚   â”‚  â”‚  3. å†·æ•°æ®è¯»å– (io_uring)                   â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ å¼‚æ­¥ I/O                              â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ é¢„è¯»ä¼˜åŒ–                              â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ P99 < 20ms                           â”‚  â”‚    â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚   â”‚       ç½‘ç»œä¼ è¾“è·¯å¾„ (Network Transfer)              â”‚    â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚
â”‚   â”‚  â”‚  sendfile() é›¶æ‹·è´                          â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ å†…æ ¸ç›´æ¥ä¼ è¾“                          â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ CPU é›¶æ‹·è´                            â”‚  â”‚    â”‚
â”‚   â”‚  â”‚     â€¢ ååé‡æå‡ 2-3x                        â”‚  â”‚    â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.3 å…³é”®æŠ€æœ¯å®ç°

#### 3.3.1 WAL (Write-Ahead Log) - Direct I/O

**è®¾è®¡ç›®æ ‡**ï¼šå¯é æ€§ä¼˜å…ˆï¼ŒP99 å»¶æ—¶ < 2ms

```rust
use std::fs::OpenOptions;
use std::io::Write;
use std::os::unix::fs::OpenOptionsExt;
use std::alloc::{alloc, Layout};

/// WAL å†™å…¥å¼•æ“ï¼ˆDirect I/Oï¼‰
pub struct WalEngine {
    file: std::fs::File,
    buffer: AlignedBuffer,
}

/// 4KB å¯¹é½ç¼“å†²åŒº
struct AlignedBuffer {
    ptr: *mut u8,
    size: usize,
    offset: usize,
}

impl AlignedBuffer {
    fn new(size: usize) -> Self {
        let align = 4096;
        let aligned_size = (size + align - 1) / align * align;
        
        unsafe {
            let layout = Layout::from_size_align(aligned_size, align).unwrap();
            let ptr = alloc(layout);
            
            AlignedBuffer {
                ptr,
                size: aligned_size,
                offset: 0,
            }
        }
    }
    
    fn write(&mut self, data: &[u8]) -> Result<(), std::io::Error> {
        if self.offset + data.len() > self.size {
            return Err(std::io::Error::new(
                std::io::ErrorKind::OutOfMemory,
                "Buffer full"
            ));
        }
        
        unsafe {
            std::ptr::copy_nonoverlapping(
                data.as_ptr(),
                self.ptr.add(self.offset),
                data.len()
            );
        }
        
        self.offset += data.len();
        Ok(())
    }
    
    fn as_slice(&self) -> &[u8] {
        unsafe { std::slice::from_raw_parts(self.ptr, self.offset) }
    }
    
    fn clear(&mut self) {
        self.offset = 0;
    }
}

impl WalEngine {
    pub fn new(path: &str) -> std::io::Result<Self> {
        // Direct I/O æ‰“å¼€æ–‡ä»¶
        let file = OpenOptions::new()
            .write(true)
            .create(true)
            .custom_flags(libc::O_DIRECT | libc::O_SYNC)
            .open(path)?;
        
        Ok(WalEngine {
            file,
            buffer: AlignedBuffer::new(4096 * 64), // 256KB
        })
    }
    
    /// å†™å…¥ WALï¼ˆåŒæ­¥æŒä¹…åŒ–ï¼‰
    pub fn append(&mut self, record: &[u8]) -> std::io::Result<u64> {
        // 1. å†™å…¥å¯¹é½ç¼“å†²åŒº
        self.buffer.write(record)?;
        
        // 2. åˆ·ç›˜ï¼ˆDirect I/O + fsyncï¼‰
        self.flush()?;
        
        Ok(self.buffer.offset as u64)
    }
    
    /// æ‰¹é‡å†™å…¥
    pub fn append_batch(&mut self, records: &[&[u8]]) -> std::io::Result<Vec<u64>> {
        let mut offsets = Vec::new();
        
        for record in records {
            self.buffer.write(record)?;
            offsets.push(self.buffer.offset as u64);
        }
        
        self.flush()?;
        
        Ok(offsets)
    }
    
    fn flush(&mut self) -> std::io::Result<()> {
        // Direct I/O å†™å…¥ï¼ˆ4KB å¯¹é½ï¼‰
        let data = self.buffer.as_slice();
        self.file.write_all(data)?;
        
        // ç¡®ä¿æŒä¹…åŒ–ï¼ˆfsyncï¼‰
        self.file.sync_all()?;
        
        self.buffer.clear();
        Ok(())
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
#[tokio::main]
async fn main() -> std::io::Result<()> {
    let mut wal = WalEngine::new("./data/wal.log")?;
    
    // å•æ¡å†™å…¥
    let offset = wal.append(b"Message 1")?;
    println!("Written at offset: {}", offset);
    
    // æ‰¹é‡å†™å…¥
    let offsets = wal.append_batch(&[
        b"Message 2",
        b"Message 3",
        b"Message 4",
    ])?;
    println!("Batch written: {:?}", offsets);
    
    Ok(())
}
```

**æ€§èƒ½ç‰¹ç‚¹**ï¼š
- âœ… P99 å»¶æ—¶ < 2ms
- âœ… å¼ºä¸€è‡´æ€§ï¼ˆfsyncï¼‰
- âœ… æ•°æ®é›¶ä¸¢å¤±
- âš ï¸ ååç•¥ä½äº Buffered I/O

---

#### 3.3.2 æ•°æ®æ–‡ä»¶ - io_uring å¼‚æ­¥æ‰¹é‡å†™å…¥

**è®¾è®¡ç›®æ ‡**ï¼šååé‡ä¼˜å…ˆï¼Œæ‰¹é‡å¼‚æ­¥å†™å…¥

```rust
use tokio_uring::fs::File;

/// æ•°æ®æ–‡ä»¶å¼•æ“ï¼ˆio_uringï¼‰
pub struct DataFileEngine {
    file: File,
    offset: u64,
}

impl DataFileEngine {
    pub async fn create(path: &str) -> std::io::Result<Self> {
        let file = File::create(path).await?;
        
        Ok(DataFileEngine {
            file,
            offset: 0,
        })
    }
    
    /// å¼‚æ­¥æ‰¹é‡å†™å…¥
    pub async fn append_batch(&mut self, records: Vec<Vec<u8>>) 
        -> std::io::Result<Vec<u64>> 
    {
        let mut offsets = Vec::new();
        let mut buffer = Vec::new();
        
        // 1. åˆå¹¶ä¸ºä¸€ä¸ªå¤§ç¼“å†²åŒº
        for record in records {
            offsets.push(self.offset + buffer.len() as u64);
            buffer.extend_from_slice(&record);
        }
        
        // 2. ä¸€æ¬¡æ€§å¼‚æ­¥å†™å…¥ï¼ˆio_uringï¼‰
        let (result, _) = self.file.write_at(buffer, self.offset).await;
        result?;
        
        self.offset += offsets.last().unwrap();
        
        Ok(offsets)
    }
    
    /// å¼‚æ­¥è¯»å–
    pub async fn read_at(&self, offset: u64, len: usize) 
        -> std::io::Result<Vec<u8>> 
    {
        let buf = vec![0u8; len];
        let (result, buf) = self.file.read_at(buf, offset).await;
        result?;
        
        Ok(buf)
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
fn main() -> std::io::Result<()> {
    tokio_uring::start(async {
        let mut engine = DataFileEngine::create("./data/messages.log").await?;
        
        // æ‰¹é‡å¼‚æ­¥å†™å…¥
        let records = vec![
            b"Message 1".to_vec(),
            b"Message 2".to_vec(),
            b"Message 3".to_vec(),
        ];
        
        let offsets = engine.append_batch(records).await?;
        println!("Batch written: {:?}", offsets);
        
        // å¼‚æ­¥è¯»å–
        let data = engine.read_at(0, 9).await?;
        println!("Read: {:?}", String::from_utf8_lossy(&data));
        
        Ok(())
    })
}
```

**æ€§èƒ½ç‰¹ç‚¹**ï¼š
- âœ… ååé‡æå‡ 2-3x
- âœ… CPU ä½¿ç”¨é™ä½ 60%
- âœ… æ‰¹é‡å†™å…¥ä¼˜åŒ–
- âš ï¸ éœ€è¦ Linux 5.1+

---

#### 3.3.3 çƒ­æ•°æ®è¯»å– - Mmap é›¶æ‹·è´

**è®¾è®¡ç›®æ ‡**ï¼šçƒ­æ•°æ®è¯»å– P99 < 5ms

```rust
use memmap2::Mmap;
use std::fs::File;
use std::sync::Arc;

/// Segment ç®¡ç†å™¨ï¼ˆMmapï¼‰
pub struct SegmentManager {
    segments: Vec<Arc<MmapSegment>>,
    max_hot_segments: usize,
}

struct MmapSegment {
    id: u64,
    mmap: Mmap,
    size: usize,
}

impl SegmentManager {
    pub fn new(max_hot_segments: usize) -> Self {
        SegmentManager {
            segments: Vec::new(),
            max_hot_segments,
        }
    }
    
    /// åŠ è½½ Segmentï¼ˆMmap æ˜ å°„ï¼‰
    pub fn load_segment(&mut self, path: &str, id: u64) 
        -> std::io::Result<Arc<MmapSegment>> 
    {
        let file = File::open(path)?;
        let size = file.metadata()?.len() as usize;
        let mmap = unsafe { Mmap::map(&file)? };
        
        let segment = Arc::new(MmapSegment { id, mmap, size });
        
        // LRU æ·˜æ±°
        if self.segments.len() >= self.max_hot_segments {
            self.segments.remove(0);
        }
        
        self.segments.push(segment.clone());
        
        Ok(segment)
    }
    
    /// é›¶æ‹·è´è¯»å–
    pub fn read(&self, segment_id: u64, offset: usize, len: usize) 
        -> Option<&[u8]> 
    {
        for segment in &self.segments {
            if segment.id == segment_id {
                if offset + len <= segment.size {
                    return Some(&segment.mmap[offset..offset + len]);
                }
            }
        }
        None
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
fn main() -> std::io::Result<()> {
    let mut manager = SegmentManager::new(3);
    
    // åŠ è½½ Segment
    manager.load_segment("./data/segment-0.log", 0)?;
    manager.load_segment("./data/segment-1.log", 1)?;
    
    // é›¶æ‹·è´è¯»å–
    if let Some(data) = manager.read(0, 0, 100) {
        println!("Read {} bytes", data.len());
    }
    
    Ok(())
}
```

**æ€§èƒ½ç‰¹ç‚¹**ï¼š
- âœ… é›¶æ‹·è´ï¼ˆç›´æ¥è¿”å›å¼•ç”¨ï¼‰
- âœ… éšæœºè¯» P99 < 5ms
- âœ… æ“ä½œç³»ç»Ÿè‡ªåŠ¨é¡µç®¡ç†
- âš ï¸ ä»…é€‚ç”¨äºçƒ­æ•°æ®

---

#### 3.3.4 ç½‘ç»œä¼ è¾“ - sendfile é›¶æ‹·è´

**è®¾è®¡ç›®æ ‡**ï¼šç½‘ç»œä¼ è¾“ååé‡æå‡ 2-3x

```rust
use std::fs::File;
use std::net::TcpStream;
use std::os::unix::io::AsRawFd;

/// æ¶ˆæ¯ä¼ è¾“å¼•æ“ï¼ˆsendfileï¼‰
pub struct MessageTransfer {
    file: File,
}

impl MessageTransfer {
    pub fn new(path: &str) -> std::io::Result<Self> {
        let file = File::open(path)?;
        Ok(MessageTransfer { file })
    }
    
    /// é›¶æ‹·è´ä¼ è¾“æ¶ˆæ¯
    pub fn send_message(
        &self,
        stream: &TcpStream,
        offset: u64,
        len: usize,
    ) -> std::io::Result<()> {
        let file_fd = self.file.as_raw_fd();
        let socket_fd = stream.as_raw_fd();
        
        let mut offset_mut = offset as i64;
        let mut remaining = len;
        
        // sendfile é›¶æ‹·è´ä¼ è¾“
        while remaining > 0 {
            let sent = unsafe {
                libc::sendfile(
                    socket_fd,
                    file_fd,
                    &mut offset_mut as *mut i64,
                    remaining,
                )
            };
            
            if sent < 0 {
                return Err(std::io::Error::last_os_error());
            }
            
            remaining -= sent as usize;
        }
        
        Ok(())
    }
    
    /// æ‰¹é‡ä¼ è¾“æ¶ˆæ¯
    pub fn send_batch(
        &self,
        stream: &TcpStream,
        messages: &[(u64, usize)], // (offset, len)
    ) -> std::io::Result<()> {
        for (offset, len) in messages {
            self.send_message(stream, *offset, *len)?;
        }
        Ok(())
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
fn main() -> std::io::Result<()> {
    let transfer = MessageTransfer::new("./data/messages.log")?;
    let stream = TcpStream::connect("127.0.0.1:9092")?;
    
    // é›¶æ‹·è´ä¼ è¾“
    transfer.send_message(&stream, 0, 1024)?;
    
    // æ‰¹é‡ä¼ è¾“
    transfer.send_batch(&stream, &[
        (0, 1024),
        (1024, 2048),
        (3072, 512),
    ])?;
    
    Ok(())
}
```

**æ€§èƒ½ç‰¹ç‚¹**ï¼š
- âœ… ååé‡æå‡ 2-3x
- âœ… CPU ä½¿ç”¨é™ä½ 70%
- âœ… æ— ç”¨æˆ·ç©ºé—´æ‹·è´
- âœ… DMA ç›´æ¥ä¼ è¾“

---

#### 3.3.5 å®Œæ•´ Journal Engine å®ç°

```rust
use tokio_uring::fs::File as UringFile;
use memmap2::Mmap;
use std::fs::File;
use std::sync::Arc;
use std::collections::HashMap;

/// Journal Engine å®Œæ•´å®ç°
pub struct JournalEngine {
    // å†™å…¥ï¼šWAL + æ•°æ®æ–‡ä»¶
    wal: WalEngine,
    data_file: UringFile,
    
    // è¯»å–ï¼šMmap + ç´¢å¼•
    segments: SegmentManager,
    index: IndexEngine,
    
    // ç½‘ç»œï¼šsendfile
    transfer: MessageTransfer,
    
    // é…ç½®
    config: JournalConfig,
}

pub struct JournalConfig {
    pub segment_size: u64,        // 1GB
    pub hot_segments: usize,       // 3 ä¸ª
    pub batch_size: usize,         // 256KB
    pub enable_compression: bool,  // å¯é€‰
}

impl JournalEngine {
    pub async fn create(path: &str, config: JournalConfig) 
        -> std::io::Result<Self> 
    {
        let wal = WalEngine::new(&format!("{}/wal.log", path))?;
        let data_file = UringFile::create(&format!("{}/data.log", path)).await?;
        let segments = SegmentManager::new(config.hot_segments);
        let index = IndexEngine::new(&format!("{}/index", path))?;
        let transfer = MessageTransfer::new(&format!("{}/data.log", path))?;
        
        Ok(JournalEngine {
            wal,
            data_file,
            segments,
            index,
            transfer,
            config,
        })
    }
    
    /// å†™å…¥æ¶ˆæ¯ï¼ˆé«˜å¯é ï¼‰
    pub async fn append(&mut self, message: Vec<u8>) 
        -> std::io::Result<u64> 
    {
        // 1. å†™å…¥ WALï¼ˆDirect I/Oï¼‰
        let wal_offset = self.wal.append(&message)?;
        
        // 2. å†™å…¥æ•°æ®æ–‡ä»¶ï¼ˆio_uringï¼‰
        let (result, _) = self.data_file.write_at(
            message.clone(), 
            wal_offset
        ).await;
        result?;
        
        // 3. æ›´æ–°ç´¢å¼•
        self.index.insert(wal_offset, message.len())?;
        
        Ok(wal_offset)
    }
    
    /// æ‰¹é‡å†™å…¥ï¼ˆé«˜ååï¼‰
    pub async fn append_batch(&mut self, messages: Vec<Vec<u8>>) 
        -> std::io::Result<Vec<u64>> 
    {
        // 1. WAL æ‰¹é‡å†™å…¥
        let refs: Vec<&[u8]> = messages.iter().map(|m| m.as_slice()).collect();
        let wal_offsets = self.wal.append_batch(&refs)?;
        
        // 2. æ•°æ®æ–‡ä»¶æ‰¹é‡å†™å…¥ï¼ˆio_uringï¼‰
        let mut buffer = Vec::new();
        for msg in &messages {
            buffer.extend_from_slice(msg);
        }
        
        let (result, _) = self.data_file.write_at(
            buffer, 
            wal_offsets[0]
        ).await;
        result?;
        
        // 3. æ‰¹é‡æ›´æ–°ç´¢å¼•
        for (i, offset) in wal_offsets.iter().enumerate() {
            self.index.insert(*offset, messages[i].len())?;
        }
        
        Ok(wal_offsets)
    }
    
    /// è¯»å–æ¶ˆæ¯ï¼ˆé›¶æ‹·è´ï¼‰
    pub fn read(&self, offset: u64, len: usize) -> std::io::Result<&[u8]> {
        // 1. å°è¯•ä» Mmap è¯»å–ï¼ˆçƒ­æ•°æ®ï¼‰
        let segment_id = offset / self.config.segment_size;
        
        if let Some(data) = self.segments.read(
            segment_id, 
            (offset % self.config.segment_size) as usize, 
            len
        ) {
            return Ok(data);
        }
        
        // 2. å†·æ•°æ®é™çº§åˆ°æ™®é€šè¯»å–
        // (è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥å¼‚æ­¥åŠ è½½)
        Err(std::io::Error::new(
            std::io::ErrorKind::NotFound,
            "Segment not in hot cache"
        ))
    }
    
    /// ç½‘ç»œä¼ è¾“ï¼ˆé›¶æ‹·è´ï¼‰
    pub fn send_to_client(
        &self,
        stream: &std::net::TcpStream,
        offset: u64,
        len: usize,
    ) -> std::io::Result<()> {
        self.transfer.send_message(stream, offset, len)
    }
}

/// ç´¢å¼•å¼•æ“ï¼ˆç®€åŒ–å®ç°ï¼‰
struct IndexEngine {
    offsets: HashMap<u64, usize>,
}

impl IndexEngine {
    fn new(_path: &str) -> std::io::Result<Self> {
        Ok(IndexEngine {
            offsets: HashMap::new(),
        })
    }
    
    fn insert(&mut self, offset: u64, len: usize) -> std::io::Result<()> {
        self.offsets.insert(offset, len);
        Ok(())
    }
}
```

---

## å››ã€å…¶ä»–å­˜å‚¨å¼•æ“å®ç°æ–¹æ¡ˆ

### 4.1 Memory å­˜å‚¨å¼•æ“

**é€‚ç”¨åœºæ™¯**ï¼šæä½å»¶æ—¶ã€å…è®¸ä¸¢å¤±

```rust
use std::collections::HashMap;
use std::sync::Arc;
use parking_lot::RwLock;

/// å†…å­˜å­˜å‚¨å¼•æ“
pub struct MemoryEngine {
    data: Arc<RwLock<HashMap<u64, Vec<u8>>>>,
    next_offset: Arc<RwLock<u64>>,
}

impl MemoryEngine {
    pub fn new() -> Self {
        MemoryEngine {
            data: Arc::new(RwLock::new(HashMap::new())),
            next_offset: Arc::new(RwLock::new(0)),
        }
    }
    
    /// å†™å…¥ï¼ˆé›¶æ‹·è´ï¼Œç›´æ¥å­˜å‚¨ï¼‰
    pub fn append(&self, message: Vec<u8>) -> u64 {
        let mut offset = self.next_offset.write();
        let current_offset = *offset;
        
        self.data.write().insert(current_offset, message);
        
        *offset += 1;
        current_offset
    }
    
    /// è¯»å–ï¼ˆé›¶æ‹·è´ï¼Œè¿”å›å¼•ç”¨ï¼‰
    pub fn read(&self, offset: u64) -> Option<Vec<u8>> {
        self.data.read().get(&offset).cloned()
    }
}
```

**æ€§èƒ½ç‰¹ç‚¹**ï¼š
- P99 < 1ms
- QPS > 1000ä¸‡
- æ— æŒä¹…åŒ–

---

### 4.2 å¯¹è±¡å­˜å‚¨å¼•æ“ï¼ˆS3/MinIOï¼‰

**é€‚ç”¨åœºæ™¯**ï¼šPB çº§å­˜å‚¨ã€æˆæœ¬ä¼˜åŒ–

```rust
use aws_sdk_s3::Client;
use aws_sdk_s3::primitives::ByteStream;

/// S3 å­˜å‚¨å¼•æ“
pub struct S3Engine {
    client: Client,
    bucket: String,
}

impl S3Engine {
    pub fn new(client: Client, bucket: String) -> Self {
        S3Engine { client, bucket }
    }
    
    /// å†™å…¥ï¼ˆæ‰¹é‡ä¸Šä¼ ï¼‰
    pub async fn append_batch(&self, messages: Vec<Vec<u8>>) 
        -> Result<Vec<String>, Box<dyn std::error::Error>> 
    {
        let mut keys = Vec::new();
        
        for (i, msg) in messages.iter().enumerate() {
            let key = format!("messages/{}.msg", uuid::Uuid::new_v4());
            
            self.client
                .put_object()
                .bucket(&self.bucket)
                .key(&key)
                .body(ByteStream::from(msg.clone()))
                .send()
                .await?;
            
            keys.push(key);
        }
        
        Ok(keys)
    }
    
    /// è¯»å–
    pub async fn read(&self, key: &str) 
        -> Result<Vec<u8>, Box<dyn std::error::Error>> 
    {
        let resp = self.client
            .get_object()
            .bucket(&self.bucket)
            .key(key)
            .send()
            .await?;
        
        let data = resp.body.collect().await?.into_bytes().to_vec();
        Ok(data)
    }
}
```

**æ€§èƒ½ç‰¹ç‚¹**ï¼š
- æˆæœ¬æœ€ä½ï¼ˆï¿¥0.1/GB/æœˆï¼‰
- P99 å»¶æ—¶ 50-200ms
- æ— é™æ‰©å±•

---

## äº”ã€æ··åˆå­˜å‚¨æ¶æ„è®¾è®¡

### 5.1 æ™ºèƒ½åˆ†å±‚å­˜å‚¨

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              æ™ºèƒ½åˆ†å±‚å­˜å‚¨æ¶æ„                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  [çƒ­æ•°æ®] æœ€è¿‘ 1 å°æ—¶                                 â”‚
â”‚  â”œâ”€ Memory (å¯é€‰)                                   â”‚
â”‚  â”œâ”€ Mmap (é›¶æ‹·è´è¯»å–)                                â”‚
â”‚  â””â”€ P99 < 5ms                                       â”‚
â”‚                                                     â”‚
â”‚  [æ¸©æ•°æ®] æœ€è¿‘ 24 å°æ—¶                                â”‚
â”‚  â”œâ”€ Local SSD (Journal Engine)                     â”‚
â”‚  â”œâ”€ å¼‚æ­¥ I/O                                        â”‚
â”‚  â””â”€ P99 < 20ms                                      â”‚
â”‚                                                     â”‚
â”‚  [å†·æ•°æ®] å†å²æ•°æ®                                    â”‚
â”‚  â”œâ”€ S3 / MinIO                                      â”‚
â”‚  â”œâ”€ æ‰¹é‡å½’æ¡£                                         â”‚
â”‚  â””â”€ P99 < 200ms                                     â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 è‡ªåŠ¨å†·çƒ­åˆ†ç¦»

```rust
use std::time::{SystemTime, UNIX_EPOCH};

/// å†·çƒ­åˆ†ç¦»ç­–ç•¥
pub enum DataTier {
    Hot,      // å†…å­˜/Mmap
    Warm,     // æœ¬åœ° SSD
    Cold,     // å¯¹è±¡å­˜å‚¨
}

pub struct TieringPolicy {
    hot_duration: u64,   // 1 å°æ—¶
    warm_duration: u64,  // 24 å°æ—¶
}

impl TieringPolicy {
    /// æ ¹æ®æ—¶é—´åˆ¤æ–­æ•°æ®å±‚çº§
    pub fn get_tier(&self, timestamp: u64) -> DataTier {
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();
        
        let age = now - timestamp;
        
        if age < self.hot_duration {
            DataTier::Hot
        } else if age < self.warm_duration {
            DataTier::Warm
        } else {
            DataTier::Cold
        }
    }
}

/// æ··åˆå­˜å‚¨å¼•æ“
pub struct HybridEngine {
    memory: MemoryEngine,
    journal: JournalEngine,
    s3: S3Engine,
    policy: TieringPolicy,
}

impl HybridEngine {
    /// æ™ºèƒ½è¯»å–ï¼ˆè‡ªåŠ¨é€‰æ‹©å­˜å‚¨å±‚ï¼‰
    pub async fn read(&self, offset: u64, timestamp: u64) 
        -> std::io::Result<Vec<u8>> 
    {
        match self.policy.get_tier(timestamp) {
            DataTier::Hot => {
                // ä»å†…å­˜è¯»å–
                self.memory.read(offset)
                    .ok_or_else(|| std::io::Error::new(
                        std::io::ErrorKind::NotFound,
                        "Not in memory"
                    ))
            }
            DataTier::Warm => {
                // ä» Journal Engine è¯»å–
                self.journal.read(offset, 1024)
                    .map(|data| data.to_vec())
            }
            DataTier::Cold => {
                // ä» S3 è¯»å–
                self.s3.read(&format!("msg-{}", offset))
                    .await
                    .map_err(|e| std::io::Error::new(
                        std::io::ErrorKind::Other,
                        e
                    ))
            }
        }
    }
}
```

---

## å…­ã€æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯æ€»ç»“

### 6.1 é›¶æ‹·è´æŠ€æœ¯åº”ç”¨çŸ©é˜µ

| åœºæ™¯ | é›¶æ‹·è´æŠ€æœ¯ | æ€§èƒ½æå‡ | é€‚ç”¨æ¡ä»¶ |
|------|----------|---------|---------|
| **WAL å†™å…¥** | Direct I/O | å»¶æ—¶ç¨³å®šæ€§ â¬† 50% | å¯é æ€§ä¼˜å…ˆ |
| **æ‰¹é‡å†™å…¥** | io_uring | ååé‡ â¬† 2-3x | Linux 5.1+ |
| **çƒ­æ•°æ®è¯»å–** | Mmap | å»¶æ—¶ â¬‡ 70% | æ–‡ä»¶ < å†…å­˜ |
| **ç½‘ç»œä¼ è¾“** | sendfile | ååé‡ â¬† 2-3x | æ–‡ä»¶ â†’ ç½‘ç»œ |
| **å†…å­˜å­˜å‚¨** | ç›´æ¥å¼•ç”¨ | å»¶æ—¶ â¬‡ 90% | å…è®¸ä¸¢å¤± |

### 6.2 Rust æ€§èƒ½ä¼˜åŠ¿

```
Java (Kafka/Pulsar)        Rust (RobustMQ)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

å»¶æ—¶åˆ†å¸ƒ                    å»¶æ—¶åˆ†å¸ƒ
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ P50:  5ms     â”‚          â”‚ P50:  2ms     â”‚ â¬‡ 60%
â”‚ P99: 50ms     â”‚   VS     â”‚ P99:  8ms     â”‚ â¬‡ 84%
â”‚ P999:500ms    â”‚          â”‚ P999: 20ms    â”‚ â¬‡ 96%
â”‚               â”‚          â”‚               â”‚
â”‚ GC åœé¡¿æ˜æ˜¾   â”‚          â”‚ æ—  GC åœé¡¿    â”‚ âœ…
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ååé‡                      ååé‡
â€¢ å•æœº 50ä¸‡ msg/s          â€¢ å•æœº 100ä¸‡+ msg/s â¬† 2x
â€¢ GC å¯¼è‡´æŠ–åŠ¨              â€¢ ç¨³å®šæ— æŠ–åŠ¨          âœ…

CPU ä½¿ç”¨                   CPU ä½¿ç”¨
â€¢ 60-80%                   â€¢ 30-50%             â¬‡ 40%
```

---

## ä¸ƒã€å®ç°è·¯çº¿å›¾

### 7.1 é˜¶æ®µä¸€ï¼šJournal Engine MVPï¼ˆQ1 2025ï¼‰

**ç›®æ ‡**ï¼šå®Œæˆæ ¸å¿ƒå­˜å‚¨å¼•æ“ï¼Œæ”¯æŒä½å»¶æ—¶é«˜åååœºæ™¯

- âœ… WAL (Direct I/O)
- âœ… æ•°æ®æ–‡ä»¶ (io_uring)
- âœ… Mmap çƒ­æ•°æ®è¯»å–
- âœ… sendfile ç½‘ç»œä¼ è¾“
- âœ… åŸºç¡€ç´¢å¼•

**æ€§èƒ½æŒ‡æ ‡**ï¼š
- P99 < 10ms
- åå > 50ä¸‡ msg/s
- æ”¯æŒå¤šå‰¯æœ¬

---

### 7.2 é˜¶æ®µäºŒï¼šæ’ä»¶åŒ–å­˜å‚¨å®Œå–„ï¼ˆQ2 2025ï¼‰

**ç›®æ ‡**ï¼šå®Œæˆå…¶ä»–å­˜å‚¨å¼•æ“ï¼Œæ”¯æŒå¤šåœºæ™¯

- âœ… Memory å¼•æ“ä¼˜åŒ–
- âœ… RocksDB å¼•æ“ä¼˜åŒ–
- ğŸš§ File å¼•æ“å¼€å‘
- ğŸš§ S3/MinIO å¼•æ“å¼€å‘
- ğŸš§ Redis å¼•æ“å¼€å‘

**æ€§èƒ½æŒ‡æ ‡**ï¼š
- Memory: P99 < 1ms
- S3: æˆæœ¬é™ä½ 70%

---

### 7.3 é˜¶æ®µä¸‰ï¼šæ™ºèƒ½åˆ†å±‚å­˜å‚¨ï¼ˆQ3 2025ï¼‰

**ç›®æ ‡**ï¼šå®ç°å†·çƒ­åˆ†ç¦»ï¼Œé™ä½æˆæœ¬

- ğŸš§ è‡ªåŠ¨åˆ†å±‚ç­–ç•¥
- ğŸš§ æ•°æ®è¿ç§»
- ğŸš§ æ™ºèƒ½é¢„è¯»
- ğŸš§ å‹ç¼©ä¼˜åŒ–

**æ€§èƒ½æŒ‡æ ‡**ï¼š
- æˆæœ¬é™ä½ 50-70%
- çƒ­æ•°æ®æ€§èƒ½æ— æŸ

---

### 7.4 é˜¶æ®µå››ï¼šæè‡´æ€§èƒ½ä¼˜åŒ–ï¼ˆQ4 2025ï¼‰

**ç›®æ ‡**ï¼šä¸šç•Œé¢†å…ˆæ€§èƒ½

- ğŸš§ DPDK ç½‘ç»œåŠ é€Ÿ
- ğŸš§ SPDK å­˜å‚¨åŠ é€Ÿ
- ğŸš§ Huge Pages ä¼˜åŒ–
- ğŸš§ NUMA æ„ŸçŸ¥

**æ€§èƒ½æŒ‡æ ‡**ï¼š
- P99 < 5ms
- åå > 200ä¸‡ msg/s
- è¶…è¶Š Kafka

---

## å…«ã€æ€§èƒ½åŸºå‡†æµ‹è¯•

### 8.1 æµ‹è¯•ç¯å¢ƒ

```
ç¡¬ä»¶é…ç½®ï¼š
â€¢ CPU: Intel Xeon Gold 6248R (24 æ ¸ 48 çº¿ç¨‹)
â€¢ å†…å­˜: 128GB DDR4 3200MHz
â€¢ å­˜å‚¨: NVMe SSD 2TB (Samsung PM1733)
â€¢ ç½‘ç»œ: 10Gbps

è½¯ä»¶é…ç½®ï¼š
â€¢ OS: Ubuntu 22.04 LTS (Kernel 5.15)
â€¢ Rust: 1.75.0
â€¢ æ¶ˆæ¯å¤§å°: 1KB
â€¢ å‰¯æœ¬æ•°: 3
```

### 8.2 é¢„æœŸæ€§èƒ½æŒ‡æ ‡

| åœºæ™¯ | P50 | P99 | P999 | ååé‡ | å¯¹æ¯” Kafka |
|------|-----|-----|------|--------|-----------|
| **Journal Engine** | 2ms | 8ms | 20ms | 100ä¸‡/s | â¬† 2x |
| **Memory** | 0.1ms | 0.5ms | 1ms | 1000ä¸‡/s | â¬† 10x |
| **S3 (æ‰¹é‡)** | 50ms | 200ms | 500ms | 10ä¸‡/s | â¬‡ å»¶æ—¶ç‰ºç‰² |
| **æ··åˆå­˜å‚¨** | 3ms | 15ms | 50ms | 80ä¸‡/s | â¬† 1.5x |

### 8.3 é›¶æ‹·è´æ€§èƒ½æå‡

| æŠ€æœ¯ | ä¼ ç»Ÿæ–¹å¼ | é›¶æ‹·è´ | æå‡ |
|------|---------|--------|------|
| **ç½‘ç»œä¼ è¾“ (sendfile)** | 2.8s/GB | 1.1s/GB | â¬† 2.5x |
| **çƒ­æ•°æ®è¯»å– (Mmap)** | 15ms | 5ms | â¬† 3x |
| **æ‰¹é‡å†™å…¥ (io_uring)** | 50ä¸‡/s | 120ä¸‡/s | â¬† 2.4x |
| **å†…å­˜å­˜å‚¨ (ç›´æ¥å¼•ç”¨)** | 1Î¼s | 0.1Î¼s | â¬† 10x |

---

## ä¹ã€æœ€ä½³å®è·µä¸å»ºè®®

### 9.1 åœºæ™¯åŒ–å­˜å‚¨é€‰æ‹©

```
åœºæ™¯å†³ç­–æ ‘ï¼š

ä½ çš„åº”ç”¨åœºæ™¯æ˜¯ä»€ä¹ˆï¼Ÿ
â”‚
â”œâ”€ ã€é‡‘èäº¤æ˜“ã€‘å»¶æ—¶ < 1msï¼Œå…è®¸ä¸¢å¤±
â”‚   â†’ Memory + Mmap
â”‚   â†’ P99 < 1ms, QPS 1000ä¸‡+
â”‚
â”œâ”€ ã€æµå¼å¤„ç†ã€‘å»¶æ—¶ < 10msï¼Œé«˜ååï¼ŒæŒä¹…åŒ–
â”‚   â†’ Journal Engine (é»˜è®¤)
â”‚   â†’ P99 < 10ms, åå 100ä¸‡/s
â”‚
â”œâ”€ ã€å¤§æ•°æ®ã€‘PB çº§ï¼Œæˆæœ¬æ•æ„Ÿ
â”‚   â†’ S3/MinIO + æ™ºèƒ½åˆ†å±‚
â”‚   â†’ æˆæœ¬é™ä½ 70%, P99 < 200ms
â”‚
â”œâ”€ ã€IoT è¾¹ç¼˜ã€‘èµ„æºå—é™ï¼Œæ— ä¾èµ–
â”‚   â†’ Memory/File
â”‚   â†’ èµ„æºå ç”¨ < 100MB
â”‚
â””â”€ ã€æ··åˆåœºæ™¯ã€‘å¤šç§éœ€æ±‚
    â†’ æ’ä»¶åŒ–æ··åˆå­˜å‚¨
    â†’ çµæ´»é…ç½®ï¼Œæ€§èƒ½/æˆæœ¬å¹³è¡¡
```

### 9.2 é…ç½®å»ºè®®

```toml
# config/storage.toml

# åœºæ™¯ä¸€ï¼šé‡‘èåœºæ™¯ï¼ˆæä½å»¶æ—¶ï¼‰
[financial]
storage_type = "Memory"
enable_persistence = false
p99_target_ms = 1

# åœºæ™¯äºŒï¼šæµå¼å¤„ç†ï¼ˆé»˜è®¤åœºæ™¯ï¼‰
[streaming]
storage_type = "JournalEngine"
wal_sync = true
enable_mmap = true
hot_segments = 3
p99_target_ms = 10

# åœºæ™¯ä¸‰ï¼šå¤§æ•°æ®ï¼ˆæˆæœ¬ä¼˜åŒ–ï¼‰
[big_data]
storage_type = "Hybrid"
hot_tier = "JournalEngine"
cold_tier = "S3"
hot_duration_hours = 24
enable_compression = true

# åœºæ™¯å››ï¼šè¾¹ç¼˜è®¡ç®—ï¼ˆè½»é‡çº§ï¼‰
[edge]
storage_type = "File"
max_memory_mb = 100
enable_mmap = true
```

### 9.3 æ€§èƒ½è°ƒä¼˜æŒ‡å—

**1. WAL è°ƒä¼˜**
```rust
// é«˜å¯é æ€§ï¼ˆé‡‘èåœºæ™¯ï¼‰
wal_config = {
    sync_mode: "fsync",     // æ¯æ¬¡ fsync
    batch_size: 1,          // å•æ¡å†™å…¥
    direct_io: true,        // Direct I/O
}

// é«˜ååé‡ï¼ˆæµå¼åœºæ™¯ï¼‰
wal_config = {
    sync_mode: "batch",     // æ‰¹é‡ fsync
    batch_size: 256,        // 256KB æ‰¹é‡
    direct_io: true,        // Direct I/O
}
```

**2. Mmap è°ƒä¼˜**
```rust
// çƒ­æ•°æ®ä¼˜åŒ–
mmap_config = {
    hot_segments: 3,        // 3 ä¸ªçƒ­ Segment
    madvise_random: false,  // é¡ºåºè¯»
    mlock: true,            // é”å®šå†…å­˜
    huge_pages: true,       // ä½¿ç”¨ Huge Pages
}
```

**3. io_uring è°ƒä¼˜**
```rust
// é«˜å¹¶å‘åœºæ™¯
uring_config = {
    queue_depth: 256,       // é˜Ÿåˆ—æ·±åº¦
    sq_thread: true,        // ä¸“ç”¨çº¿ç¨‹
    io_poll: true,          // è½®è¯¢æ¨¡å¼
}
```

---

## åã€æ€»ç»“

### 10.1 æ ¸å¿ƒä¼˜åŠ¿

RobustMQ é«˜æ€§èƒ½å­˜å‚¨å¼•æ“é€šè¿‡ä»¥ä¸‹æŠ€æœ¯å®ç°ä¸šç•Œé¢†å…ˆæ€§èƒ½ï¼š

**1. é›¶æ‹·è´æŠ€æœ¯å…¨è¦†ç›–**
- WAL: Direct I/O
- æ•°æ®å†™å…¥: io_uring
- çƒ­æ•°æ®è¯»å–: Mmap
- ç½‘ç»œä¼ è¾“: sendfile
- æ€§èƒ½æå‡: 2-3x

**2. Rust è¯­è¨€ä¼˜åŠ¿**
- æ—  GC åœé¡¿
- ç¼–è¯‘æœŸå†…å­˜å®‰å…¨
- é›¶æˆæœ¬æŠ½è±¡
- å»¶æ—¶é™ä½: 70-90%

**3. æ’ä»¶åŒ–æ¶æ„**
- 5+ å­˜å‚¨å¼•æ“
- åœºæ™¯è‡ªé€‚åº”
- æˆæœ¬å¯ä¼˜åŒ–
- çµæ´»åº¦ 100%

### 10.2 æŠ€æœ¯åˆ›æ–°ç‚¹

| åˆ›æ–°ç‚¹ | æŠ€æœ¯æ–¹æ¡ˆ | ä¸šç•Œå¯¹æ¯” |
|--------|---------|---------|
| **æ··åˆé›¶æ‹·è´** | Direct I/O + io_uring + Mmap + sendfile | é¦–åˆ›ç»„åˆæ–¹æ¡ˆ |
| **æ™ºèƒ½åˆ†å±‚** | çƒ­æ¸©å†·ä¸‰å±‚è‡ªåŠ¨åˆ†ç¦» | Pulsar éœ€æ‰‹åŠ¨é…ç½® |
| **æ’ä»¶åŒ–å­˜å‚¨** | 5+ å¼•æ“ï¼ŒTopic çº§é€‰æ‹© | Kafka å•ä¸€å­˜å‚¨ |
| **Rust å®ç°** | æ—  GCï¼Œå†…å­˜å®‰å…¨ | Redpanda C++ï¼ŒKafka Java |

### 10.3 æœªæ¥å±•æœ›

**çŸ­æœŸï¼ˆ2025ï¼‰**ï¼š
- å®Œæˆ Journal Engine æ ¸å¿ƒå¼€å‘
- å®ç°æ™ºèƒ½åˆ†å±‚å­˜å‚¨
- æ€§èƒ½è¾¾åˆ° Kafka 2x

**ä¸­æœŸï¼ˆ2026ï¼‰**ï¼š
- DPDK/SPDK åŠ é€Ÿ
- æ”¯æŒ RDMA
- æ€§èƒ½è¾¾åˆ° Kafka 3x

**é•¿æœŸï¼ˆ2027+ï¼‰**ï¼š
- ä¸šç•Œæ€§èƒ½æ ‡æ†
- æˆæœ¬é™ä½ 70%
- æ”¯æŒ 10 äº¿+ QPS

---

## å‚è€ƒèµ„æ–™

1. [RobustMQ æŠ€æœ¯è®¾è®¡ç†å¿µç»¼è¿°](02.md)
2. [RobustMQ æ•´ä½“æ¶æ„æ¦‚è¿°](06.md)
3. [å­˜å‚¨å±‚ Storage Adapter æ¶æ„](12.md)
4. [å…³äº RobustMQ å­˜å‚¨å¼•æ“çš„æ€è€ƒ](13.md)
5. [Rust é›¶æ‹·è´æŠ€æœ¯å®Œå…¨æŒ‡å—](é›¶æ‹·è´æ–‡æ¡£.md)
6. [Apache Kafka å­˜å‚¨è®¾è®¡](https://kafka.apache.org/documentation/#design_storage)
7. [Apache Pulsar åˆ†å±‚å­˜å‚¨](https://pulsar.apache.org/docs/tiered-storage-overview/)
8. [io_uring å®˜æ–¹æ–‡æ¡£](https://kernel.dk/io_uring.pdf)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**å‘å¸ƒæ—¥æœŸ**: 2025-01-03  
**ä½œè€…**: RobustMQ å›¢é˜Ÿ  
**ç‰ˆæƒ**: Apache License 2.0

