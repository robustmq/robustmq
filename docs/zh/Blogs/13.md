# 关于 RobustMQ 存储引擎的思考

RobustMQ 的定位是 ALL In One 的消息队列，在设计之初就希望它能匹配所有消息中间件能覆盖的场景。覆盖所有场景的关键是存储引擎需要能够承载各种不同的使用场景。

## 核心场景概览

RobustMQ 主要希望满足以下五类场景：

| 场景 | 核心特性 | 典型应用 |
|------|---------|---------|
| 低延时、高吞吐 | 持久化、多副本、顺序读写 | 流式处理、大数据场景 |
| 高吞吐、低成本 | 对象存储、适当牺牲延时 | 大规模数据、成本敏感场景 |
| 百万 Topic/Partition | 共享存储文件、元数据轻量 | 数据隔离、顺序性保证 |
| 极低延时、高 QPS | 内存存储、允许丢失 | 金融场景、实时数据分发 |
| 边缘消息队列 | 无依赖、轻量级、高内聚 | 边缘计算、资源受限环境 |

## 存算分离架构的必要性

存算分离架构在消息队列中有两个核心驱动因素：

### 1. 资源弹性扩展诉求
消息队列作为存储组件，具有 **CPU 使用量低、存储容量需求高** 的特性。在实际运维中常遇到两种资源不匹配的情况：
- **存储不足**：机器 CPU 空闲，但存储容量已满，添加机器造成 CPU 资源浪费
- **计算不足**：存储空间充足，但 CPU 性能不够，扩容导致存储资源浪费

**核心诉求**：存储和计算资源需要能够独立扩容，避免资源浪费。

### 2. 成本优化诉求
在云原生时代，硬盘或云盘的成本相对较高。降低存储成本的最佳方案是使用 **对象存储**（Object Storage）：
- 对象存储是目前业界最廉价的存储选择
- 对象存储本身是独立服务，天然契合存算分离架构
- 通过适当牺牲延时换取显著的成本降低

## 详细场景分析

### 场景一：低延时、高吞吐场景
**典型产品**：Kafka（行业标准）、Pulsar、Redpanda

**核心特性**：
- 数据持久化、多副本、可靠存储
- 一个 Partition 对应一个文件
- Append Only 顺序写、顺序读
- 零拷贝技术最大化读写性能

**适用场景**：流式处理、大数据场景（Kafka 是这个方向的首选产品）

---

### 场景二：高吞吐、低成本场景
**场景特点**：场景一的进阶版，数据规模持续增长，存储和网络成本成为瓶颈

**技术方案**：
- 引入对象存储，将大量数据存储在对象存储上
- 允许适当降低延时，换取成本的显著降低

**核心权衡**：牺牲一定延时 → 降低存储和网络成本

---

### 场景三：百万 Topic/Partition 场景
**业务需求**：需要大量分区来隔离数据并保证数据的顺序性

**技术挑战**：
- Kafka 模型（一个 Partition 一个文件）：小文件过多，元数据压力大，无法满足
- RocketMQ 模型（多个 MessageQueue 共享一个文件）：可支持百万级分区，但无法顺序读，吞吐量降低

**核心权衡**：分区数量 vs 读写性能

---

### 场景四：极低延时、高 QPS 场景
**典型场景**：金融场景，端到端延时控制在 1ms 内，允许丢消息

**技术特点**：
- 内存存储分发，不持久化
- 规避磁盘 I/O 延时
- 语言性能优势明显（Java 受限于语言性能难以达到）

**代表产品**：Nats（内存分发、极低延时、极高 QPS）、Apache IGGY（文件存储 + 零拷贝 + MMAP）

---

### 场景五：边缘消息队列
**核心诉求**：无依赖、轻量级、高内聚

**技术要求**：
- 占用资源少，能稳定运行
- 不依赖外部组件，只能使用内存或本地文件
- 存储模型简单，资源占用小

**特殊场景**：在极端资源受限环境（如无法运行 Java 虚拟机），编译型语言优势明显

## 语言性能的影响

通过对 Redpanda 和 Kafka 的压测对比发现，在相同硬件环境下，Redpanda 的延时表现优于 Kafka。这说明在架构和性能优化都做到位的前提下，**编程语言本身的性能差异会产生显著影响**。

Rust/C++ 等编译型语言相比 Java 在性能敏感场景中具有天然优势。

---

## 存储模型对比

消息队列的存储特性是 **Append Only**（只追加），技术上有两种存储模型：

| 存储模型 | 代表产品 | 优点 | 缺点 | 适用场景 |
|---------|---------|------|------|---------|
| 一个 Partition 一个文件 | Kafka | 极高的读写性能<br>顺序读写 | 小文件过多<br>影响硬盘性能<br>元数据压力大 | 低延时高吞吐场景<br>Partition 数量适中 |
| 多个 Partition 共享文件 | RocketMQ | 支持百万级分区<br>小文件少<br>元数据压力小 | 无法顺序读<br>读性能下降 | 百万 Topic/Partition 场景<br>分区隔离需求 |

**核心权衡**：读写性能 vs 分区数量支持

---

## 关于副本的重新思考

### 副本是否必需？
传统观点认为消息队列必须要副本，否则数据丢失无法接受。但这个结论并不绝对，**是否需要副本取决于业务特性**。

### 允许数据丢失的场景
在许多场景中，消息队列主要用于实时数据分发，业务上允许数据丢失：
- **股票最新价格**：后续数据会覆盖前面的数据，历史价格丢失不影响业务
- **传感器最新温度**：只关注最新读数，历史数据可丢弃
- **实时监控数据**：主打极低延时、高 QPS，允许少量丢失

**典型案例**：
- **Nats**：核心竞争力是内存分发、极低延时、极高 QPS
- **Apache IGGY**：主打极低延时和高吞吐，文件存储 + 零拷贝 + MMAP

### 云架构下的新选择
在云原生架构下，**底层云盘本身提供多副本存储**，可以保证不丢数据。此时应用层单副本的影响仅是：
- 该节点上的分区暂时不可用
- 数据不会丢失
- 在某些业务场景下是可接受的

---

## RobustMQ 的解决方案

综合上述场景分析，**单一存储模型或单一存储引擎无法满足所有需求**。因此，RobustMQ 采用 **插件化存储方案**，支持：
- 两种存储模型（单文件 vs 共享文件）
- 多种存储引擎（Memory、RocksDB、Journal Engine、MySQL、对象存储等）
- 灵活配置副本策略

通过这种架构，RobustMQ 能够适配从边缘到云端、从低延时到低成本的各种场景需求。

---

## 未来展望：检索聚合能力

业界已有成熟的日志解决方案：
- ELK（Elasticsearch + Logstash + Kibana）
- 阿里云 SLS（日志服务）

RobustMQ 长期设想是能够适配简单检索聚合场景，提供轻量级的 ELK 替代方案。当然，这还处于设想阶段。