---
layout: doc
sidebar: false
aside: false
pageClass: blog-post-page
---

# RobustMQ：构建下一代统一消息平台的战略思考

经过几个月深入思考，我们清晰了RobustMQ的战略定位和发展路径。这不是快速商业化的项目，而是打造伟大基础软件的长期事业。以下是我们对技术愿景、战略选择和执行理念的完整阐述。

## 愿景与技术基石

RobustMQ的核心愿景是：**在一个强大内核基础上，构建支持多种协议、适配多种场景的统一消息平台**。让企业不再需要同时部署EMQX、Kafka、RabbitMQ等多个系统，用一套RobustMQ解决IoT连接、实时流处理、微服务通信的所有消息需求。

这个愿景很大，但我们相信这是消息中间件发展的必然方向。就像Linux统一Unix碎片化，Kubernetes统一容器编排，下一代消息平台需要统一当前分散的消息基础设施。

实现这一愿景，我们采用了三层架构：最底层是Rust实现的统一消息内核，中间层是多协议适配层，最上层是场景优化。

统一内核是基石，实现了高性能路由引擎、存算分离、插件化存储、弹性调度等核心能力。这些能力协议无关、场景无关，构成技术护城河。

内核之上是协议适配层。MQTT、Kafka、AMQP等协议都是内核能力的不同表现。MQTT需要发布订阅和QoS，Kafka需要分区流处理，AMQP需要复杂路由——这些需求在内核层面有统一抽象。

应用场景层针对特定业务优化。IoT需要海量长连接管理，AI需要高吞吐低延迟，实时分析需要流处理。这些优化共享同一内核。

分层优势是：内核强大稳定后，新增协议和场景变得容易。不需要为每个协议重实现底层逻辑，只需开发适配层。这就是"一次构建，多次复用"的力量。

## 技术基石：统一内核架构

RobustMQ的技术架构采用三层设计：最底层是用Rust实现的统一消息内核，中间层是多协议适配层，最上层是各种应用场景的优化。

统一内核是整个系统的基石。我们在内核层实现了高性能消息路由引擎、存算分离架构、插件化存储抽象、弹性伸缩调度等核心能力。这些能力是协议无关、场景无关的，它们构成了RobustMQ的技术护城河。

在内核之上，我们设计了协议适配层。MQTT、Kafka、AMQP等不同的协议，本质上都是内核能力的不同表现形式。MQTT需要发布订阅和QoS保障，Kafka需要分区和流式处理，AMQP需要复杂的路由规则——这些看似不同的需求，在内核层面都能找到统一的抽象。

应用场景层则是针对特定业务场景的优化。IoT设备连接需要海量长连接管理，AI训练需要高吞吐和低延迟，实时分析需要流式处理能力——这些优化建立在协议层之上，但都共享同一个内核。

这种分层架构的优势在于：一旦内核足够强大和稳定，新增协议和场景就变得相对容易。我们不需要为每个协议重新实现底层逻辑，只需要开发适配层。这就是"一次构建，多次复用"的力量。

## 执行策略：深度优先与多场景并行

资源有限时，最大风险是"什么都想做，什么都做不好"。太多开源项目死于过度扩张：功能很多，但每个只完成60-70%，最终被抛弃。

我们的执行原则是：**一个协议做到100%完整度，才启动下一个协议开发**。这不是保守，而是对用户和技术负责。

第一个协议选MQTT：规范清晰、实现明确、测试成熟，能充分验证内核能力。MQTT的发布订阅、QoS、会话管理、遗嘱消息等特性，需要内核强大支持。MQTT做好了，说明内核稳定可靠。

100%意味着：功能完整、生产级稳定、业界领先性能、完善文档工具、充分用户验证。我们不会因为"基本能用"就急于下一协议，而是持续打磨到极致。

当MQTT达到100%后，启动Kafka开发。有了MQTT经验和成熟内核，Kafka会更顺利。同样，Kafka做到100%，然后AMQP，再其他协议。这是一个串行渐进过程，每步扎实，每个协议都是精品。

虽然协议串行，但我们不会等MQTT完全做好才接触其他场景。在专注MQTT的同时，用少量资源探索AI训练、流处理等场景。这不是分散精力，而是验证内核实力。

AI场景对消息队列要求极苛刻：微秒级延迟、高吞吐、大文件传输、弹性扩缩容。如果内核能支持AI训练，说明设计成功，能向社区展示技术实力。更重要的是，AI是热点，能帮助积累关注度。通过AI社区发声、技术会议展示、发布性能报告，吸引技术社区，建立"技术领先"品牌印象。

同样，我们会搭建Kafka协议基础框架。虽然完整开发等MQTT100%后，但提前搭建、展示进展、发布规划，能让Kafka用户知道我们在做什么，扩大潜在用户群。

这就是"多轮驱动"：MQTT是主轮，转得又快又稳；AI和Kafka是辅助轮，积累人气、验证技术、扩大影响。主轮承载实力，辅助轮创造声量。

## 多场景并行：人气与验证

虽然协议开发是串行的，但我们不会等MQTT完全做好才开始接触其他场景。在专注MQTT开发的同时，我们会用少量资源探索AI训练、流处理等其他场景。

这不是分散精力，而是有明确目的的。AI训练场景对消息队列的要求极其苛刻：微秒级延迟、高吞吐量、大文件传输、弹性扩缩容。如果我们的内核能够支持AI训练这种硬核场景，说明内核设计是成功的，也能向社区展示我们的技术实力。

更重要的是，AI场景能够帮助我们积累人气和关注度。AI是当前技术领域的热点，围绕AI的讨论和关注度远超传统的消息队列话题。通过在AI社区发声、在技术会议上展示AI场景的应用、发布相关的技术文章和性能测试报告，我们可以吸引更多技术社区的关注，建立"技术领先"的品牌印象。

同样，我们也会搭建Kafka协议的基础框架。虽然Kafka协议的完整开发要等到MQTT达到100%之后，但提前搭建框架、展示开发进展、发布技术规划，可以让Kafka用户知道我们在做什么，扩大潜在用户群，为未来的Kafka正式开发预热。

这就是我们说的"多轮驱动"：MQTT是主轮，必须转得又快又稳；AI和Kafka是辅助轮，用来积累人气、验证技术、扩大影响。主轮承载实力，辅助轮创造声量。

## 社区建设与开源之道

伟大的基础软件必然社区驱动。Linux、PostgreSQL、Kubernetes都证明了这一点。

从项目启动第一天，我们就把社区建设放在重要位置。技术博客持续输出、Discord运营、GitHub Issue及时回复、技术会议参与、培养外部贡献者——这些是日常工作。

我们不会"等产品成熟再建社区"，而是让社区伴随产品成长。早期用户反馈改进产品，外部贡献者提升代码质量，技术讨论避免闭门造车。社区活跃度是检验是否自嗨的最好标准。

Apache基金会是战略重要一环。进入孵化器不仅是品牌认证，更重要的是通过治理框架建立健康社区文化。Apache的"社区大于代码"理念、透明决策流程、规范发布机制，能帮助RobustMQ成为真正社区驱动项目。

但进入Apache不能太早。只有产品成熟、社区活跃、影响力足够大时，才是水到渠成。我们目标是以强姿态进入，快速毕业成顶级项目，而非在孵化器停滞多年。

## 技术纯粹性与长期主义

选择Rust不是赶时髦，而是深思熟虑的技术决策。主流消息队列大多用Java，生态成熟但GC停顿、内存效率、并发性能有限。C++性能更好，但开发效率低、内存安全问题突出。

Rust给我们完美选择：接近C++性能、内存安全保障、现代化开发体验。零GC停顿意味着延迟更稳定，所有权系统意味着并发更安全，强类型意味着代码更可靠。这些特性在对性能和可靠性要求极高的消息队列场景中，价值显而易见。

存算分离不是追求先进性，而是云原生时代必然选择。计算层无状态可快速扩缩容，存储层独立可灵活配置，调度层分离可智能优化资源。这种架构让RobustMQ天然具备Serverless能力，适应云原生弹性需求。

我们在技术上不妥协。不为快速推出降低代码质量，不为兼容性牺牲架构优雅，不为市场需求偏离技术本质。这种纯粹性让我们走得慢些，但确保走得远、走得稳。

我们没有商业化想法和压力，这既是优势也是考验。优势是专注技术，不被短期利益干扰；考验是如何保持长期投入和动力。

伟大的开源项目需要时间：Linux 30年成服务器标准，PostgreSQL 25年超越MySQL，Rust 10年被Linux采用，Kubernetes 7年成云原生标准。基础软件需要持续投入和坚定信念。

我们希望给自己10年时间。前5年专注技术打磨和社区建设，一个协议做到极致，积累用户口碑。技术成熟、社区活跃、影响力足够大时，商业化自然而来。但是短时间内没这个想法和思考。

## 战略关键词

RobustMQ战略可以总结为：统一、深度、耐心、开放。

统一是愿景——一个内核、一套系统，解决所有消息场景需求。深度是执行原则——一个协议做到100%，才做下一个。耐心是时间观——10年打磨技术，不急于求成。开放是态度——拥抱社区，接受检验，持续学习。

这条路很长，很不容易。市场已有优秀消息队列产品，建立差异化不容易，获得用户信任不容易，建立活跃社区不容易。但正因为不容易，才值得做。

我们相信，只要方向正确、技术过硬、社区健康、持续投入，RobustMQ会成为消息中间件领域重要一员。也许不会统治市场，但会成为技术优秀、社区活跃、值得信赖的开源项目。

这就是我们想做的事情。用10年时间，构建下一代统一消息平台，为云原生和AI时代提供更好基础设施。

路很长，但方向很清晰。我们已经上路了。