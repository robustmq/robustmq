# AI 时代的工程师困境：当 Vibe Coding 成为常态

最近在做RobustMQ的时候，我一直在思考一个让我不安的问题：当AI可以快速生成代码、Claude和Cursor成为日常开发工具的时候，我们这些写代码的人，核心竞争力到底还剩下什么？

这不是杞人忧天。我身边已经有不少工程师，包括一些曾经很强的人，开始明显地依赖AI。更让我担心的是，我自己有时候也会产生这种依赖。

## 一个让人不安的观察

过去一年，我看到一个明显的趋势：身边越来越多的工程师开始大量依赖AI写代码。需求来了，先问Claude怎么实现；AI给出代码，复制粘贴；能跑就提交。整个过程可能只需要十几分钟，效率确实高得惊人。

我理解这种诱惑。谁不想轻松一点？谁不想效率更高？但我同时也观察到一个更让人不安的现象：**这些高度依赖AI的工程师，技术能力在以肉眼可见的速度退化**。

上个月遇到一个朋友，两年前他还能手撸分布式系统，对底层理解很深。现在基本不手写代码了，全靠Copilot。聊天时我随口问了个并发问题，他想了半天说不清楚。后来他自己也承认："感觉对这些细节越来越不敏感了，离开AI确实有点慌。"

还有一次Code Review，看到一段明显有性能问题的代码——在循环里重复分配内存。我问写代码的同学，他说是AI生成的，"能跑就行"。我指出性能问题，他看了看说："确实，但我也不知道怎么改，要不让AI优化一下？"

这些小事让我开始认真思考：**AI在提升效率的同时，是不是也在悄悄掏空我们的能力？**

## 能力退化是真实存在的

编程能力不是学会了就永远拥有的知识，更像是需要持续锻炼的肌肉。长期不练，就会萎缩。

我自己就有体会。去年有段时间项目比较赶，大量用AI生成代码来提速。两个月后，有一天要手写一个复杂的算法，发现手感明显不如以前——以前信手拈来的实现，现在要想一会儿；以前一眼能看出的优化点，现在要仔细思考。那一刻我突然警醒：**才两个月不手撸，能力就开始下降了**。

这不是我一个人的问题。和几个做基础软件的朋友交流，大家都有类似的感受。有个朋友说得很直白："现在让我不用AI写代码，感觉特别不适应，就像习惯了开自动挡，突然让你开手动挡，会有点手忙脚乱。"

更可怕的是，这种退化往往是不知不觉的。你不会突然发现"我不行了"，而是在某个时刻突然意识到：遇到一个复杂问题，以前能快速定位，现在没思路了；看一段代码，以前能一眼看出问题，现在看不出了；做性能优化，以前有手感，现在没感觉了。

最要命的是，当你习惯了用AI，重新手撸代码会觉得很痛苦、很慢、很笨拙。大部分人会选择继续依赖AI，于是退化成为不可逆的趋势。

## 技术直觉的丢失

让我说说什么是"技术直觉"。

写RobustMQ的消息引擎时，我盯着一段代码看了几分钟，总觉得哪里不对。仔细分析，发现一个数据结构没有对齐到cache line，会导致false sharing。改了之后，性能提升了15%。这种"感觉哪里不对"，就是技术直觉。

这种直觉不是天生的，是手撸了大量代码、踩过无数坑之后才形成的。你写过上万行性能关键代码，优化过几十次内存布局，处理过各种并发问题，慢慢就形成了一种直觉。看到代码，不用深入分析，就能感觉到哪里可能有问题。

但这种直觉非常脆弱。如果你不再手写核心代码，不再深入底层，不再亲手优化性能，半年之后，这种直觉就开始变弱。一年之后，可能就完全消失了。

AI生成的代码，往往能跑，但不够优化。它不会考虑cache line对齐，不会优化分支预测，不会用SIMD指令。如果你有技术直觉，能看出这些问题，能手动优化。但如果你失去了直觉，就只能接受AI给的代码，永远做不到极致的性能。

做基础软件，性能往往就是核心竞争力。RobustMQ要做到微秒级延迟，每一微秒都需要抠出来。这种优化，AI做不了，必须靠人的经验和直觉。

## 什么代码必须手撸

不是所有代码都需要手撸，但核心代码必须自己写。

性能关键路径必须手撸。消息队列的核心逻辑，每一次函数调用都影响延迟，每一次内存分配都要仔细考虑。这种代码AI写不好，必须由理解底层的工程师精心打造。CPU缓存对齐、分支预测优化、SIMD指令使用，这些细节决定了性能的天花板。

架构的核心抽象必须手撸。系统的关键trait定义、模块间的接口设计、数据结构的选择，这些决定了架构的扩展性和优雅性。AI可以给出通用的方案，但做不出针对性的优化设计。这需要对业务的深刻理解，对技术的前瞻性思考，对权衡的准确判断。

疑难问题的修复必须手撸。生产环境的诡异bug、性能的突然下降、偶现的崩溃，这些问题往往需要深入到系统底层，结合日志、监控、源码、经验，系统性地排查。AI可以给建议，但定位根因和设计解决方案，还得靠人的经验和直觉。

创新性的功能必须手撸。从未有过的特性、突破性的优化、独特的技术方案，这些没有现成的参考，AI只能基于已有知识，给不出真正创新的东西。RobustMQ的多协议统一内核，这种架构设计就必须人来做，AI给不出这样的方案。

而那些重复性的代码、标准化的模式、大量的测试用例，这些可以让AI来生成，人来Review和优化。这不是偷懒，而是把时间花在更有价值的地方。关键是要能看出AI代码的问题，能够优化它，这本身就需要深厚的功力。

## 实战经验不可替代

最近在思考另一个问题：如果工程师不手撸代码，只做架构设计和技术决策，行不行？

我的答案是：不行。至少对基础软件来说，不行。

好的架构设计必须建立在丰富的实战经验之上。如果你没有手撸过高性能代码，怎么知道哪种设计性能更好？如果你没有处理过生产故障，怎么知道哪里容易出问题？如果你没有优化过内存使用，怎么知道这个架构会不会有瓶颈？

我见过一些"架构师"，画的图很漂亮，讲的理论头头是道，但一到实现就问题百出。为什么？因为他们脱离一线太久了，失去了对实际系统的感觉。他们设计的"优雅架构"，实现起来性能很差；他们认为的"小问题"，实际上是大坑。

真正厉害的人，都保持在一线。Linus Torvalds现在七十多岁了，还在Review Linux内核的每一个patch，还在写代码。为什么？因为他深知，一旦脱离代码，对内核的理解就会变浅，做出的决策质量就会下降。

做RobustMQ的时候，我一直自己写核心代码。存算分离的调度逻辑、消息路由的优化、MQTT协议的关键部分，我都会亲手实现。不是因为别人写不好，而是因为只有亲手写过，我才能真正理解这个系统，才能做出正确的架构决策。

有一次讨论是否要加一个新特性，我最初觉得很简单，应该很容易实现。但当我开始手撸代码时，发现涉及的改动比想象的大得多，而且会影响性能。如果不是自己动手，可能就做了一个错误的决策。

**远离一线，能力就会退化。不管你以前多强，不管你title多高。**

## 一个工程师的两条路

我常常想，五年后、十年后，哪些工程师会被淘汰，哪些会越来越值钱？

**第一条路：依赖AI的舒适区**

刚开始很爽。用AI写代码，效率翻倍，完成任务很快，看起来产出很高。第一年可能还会因为"效率高"被表扬。

但到了第二年、第三年，问题开始显现。底层知识开始模糊，不记得具体的系统调用了，不太确定并发模型的细节了。但没关系，AI知道，问一下就好。

再过两年，手撸代码的能力明显下降。偶尔需要现场写段代码，会觉得很不适应，就像习惯了自动挡突然开手动挡。但平时工作还行，AI都能搞定。

到了第五年，有一天遇到一个AI解决不了的复杂问题，完全卡住了。以前的同事已经成长为能独立解决难题的高级工程师了，自己却发现离开AI寸步难行。想重新手撸代码，发现已经找不回当年的感觉了。

这条路看起来轻松，实际上是在透支未来。

**第二条路：保持硬功夫**

这条路更累。核心代码坚持手撸，每一行都要思考为什么这样写。生产问题自己解决，熬夜排查root cause。性能优化自己做，一点点抠出每一微秒的延迟。

第一年会觉得比别人慢，别人用AI十分钟搞定的事情，自己要写一小时。但这一小时不是浪费，是在积累真功夫。

到了第二年、第三年，底层理解越来越深，技术直觉越来越敏锐。看代码能一眼看出问题，遇到bug能快速定位，做优化有清晰的思路。同时也学会了用AI提效，但AI是助手，不是依赖。

第五年，手撸能力加上AI工具，产出是当年的三倍。更重要的是，能解决别人解决不了的问题。那些复杂的并发bug、那些诡异的性能问题、那些需要创新的技术方案，只有自己能搞定。

这条路当下更累，但长期更有竞争力。

我选择第二条路。累是真的累，但踏实。

## AI应该怎么用

我不是反对用AI，我自己也用。关键是怎么用。

我的原则是：人先思考，人做核心，AI辅助细节。

遇到一个问题，我不会直接问AI怎么做。我会先想：这个问题的本质是什么？可能的解决方案有哪些？每个方案的权衡在哪里？哪个更适合我们的场景？思考清楚之后，再用AI来辅助实现。

写代码的时候，核心逻辑我会手撸。比如消息的调度算法，这决定了系统的性能和正确性，必须自己设计、自己实现、自己优化。每一行代码都要理解为什么这样写，每一个数据结构都要考虑性能影响。

但一些辅助代码，可以让AI生成。比如配置解析、错误处理的重复逻辑、单元测试的框架代码。AI生成后，我会仔细Review，理解每一行的作用，优化不够好的地方。如果发现AI的实现有问题，我会改。如果我解释不清楚某段代码为什么这样写，那说明我没有真正理解，这段代码就不能用。

Review AI代码的过程，也是保持技术敏感度的过程。你要能看出AI代码哪里有冗余，哪里有性能问题，哪里可以更优雅。这需要你对语言特性、算法复杂度、系统原理有深刻的理解。

我观察到，那些把AI用得好的工程师，往往底子很扎实。他们知道什么时候该用AI，什么时候不该用；知道AI生成的代码哪里可能有坑，如何优化；知道AI的边界在哪里，什么问题AI解决不了。而那些只会用AI的人，往往是底子本来就不行，或者因为依赖AI导致底子变差了。

**AI是放大器，让强者更强，但也会暴露弱者的不足。**

## 技能的用进废退

编程能力像肌肉，不练就会萎缩。

如果你坚持手撸核心代码，每写一行都思考为什么这样写，每遇到一个问题都深入到底层排查，每做一次优化都理解原理。这样一年下来，你对底层的理解会更深刻，解决问题的能力会更强，技术直觉会更敏锐。

但如果你完全依赖AI，所有代码都是复制粘贴，所有问题都问AI，从不深入思考。半年后，你会发现离开AI就不太会写代码了；一年后，对底层的理解开始模糊；两年后，技术直觉基本丢失；五年后，实际水平可能退化到初级。

这不是夸张。我见过太多例子：曾经的技术高手，因为两三年不写核心代码，能力明显下降。让他们做性能优化，做不了；让他们排查复杂问题，没思路；让他们设计架构，方案很浅显。

为什么会这样？因为技术能力不是一次性获得就永远拥有的。它需要持续练习、持续积累、持续在一线。一旦停止练习，就会退化。而且年纪越大，退化越快，恢复越难。

这对年轻工程师尤其是一个警告。如果你在职业生涯的早期就开始依赖AI，没有积累足够的底层理解和实战经验，那么你的职业天花板会非常低。也许前几年因为"效率高"还能混得不错，但五年、十年之后，当需要真功夫的时候，你会发现自己什么都不会。

## 一线的重要性

有人说，高级工程师应该做架构设计和技术决策，不需要写太多代码。这是一个危险的误区。

好的架构设计必须建立在对实际系统的深刻理解之上。如果你不写代码，不解决生产问题，不接触真实的系统运作，你的设计往往是空中楼阁。

真正优秀的架构师，都保持在一线。他们也许不需要写所有的代码，但一定会写核心的代码。他们也许不需要处理所有的问题，但一定会处理最难的问题。他们保持对系统的直接接触，保持对技术的敏感度。

远离一线是职业生涯的自杀。你会失去对技术的感觉，失去解决问题的能力，失去做出正确判断的基础。最后变成一个只会开会、画图、讲大道理的人。这种人在市场上的价值会越来越低。

在RobustMQ团队，我们要求每个人都保持在一线。不管是架构师还是工程师，都要写核心代码，都要on-call处理生产问题，都要参与技术细节的讨论。我们不要"指挥型"的人，要"战斗型"的人。

## 我的选择

写这篇文章，也是在提醒自己。

做RobustMQ的过程中，我也会面对AI的诱惑。有时候遇到一个复杂的实现，会想"要不让AI试试"。有时候赶进度，会想"先让AI生成，后面再优化"。有时候遇到一个问题，会想"问问Claude有什么建议"。

这些诱惑都很正常。AI确实能帮我们节省时间，提高效率。但我会不断提醒自己：**核心代码必须手撸，实战能力不能丢，一线不能离开**。

具体来说，我给自己定了几个原则：

性能关键的代码，必须自己写。消息路由、存储引擎、协议解析的核心部分，每一行都要自己敲，理解每一个细节。

生产问题，必须自己解决。不管多难、多复杂，都要亲手排查、亲手修复。每一个问题都是学习的机会，不能浪费。

AI生成的代码，必须完全理解。如果解释不清楚某一行为什么这样写，就不能用。Review的过程要认真，不能走过场。

这些原则听起来有点"反潮流"，毕竟大家都在拥抱AI，都在追求效率。但我相信，保持这些原则，长期看会更有竞争力。

也许我会比别人慢一些，也许短期产出不如全力用AI的人，但我的能力不会退化，我对技术的掌控力不会丢失。十年后，当需要真功夫的时候，我还能拿得出手。

## 基础软件需要真功夫

应用软件也许AI能做大部分工作，但基础软件不行。

消息队列的每一微秒延迟都重要。用户不会因为"这是AI生成的代码"就接受糟糕的性能。数据库的每一个并发控制都要仔细设计。用户不会因为"AI说这样写"就容忍数据不一致。操作系统的每一个系统调用都要优化。用户不会因为"AI帮我写的"就接受系统崩溃。

做RobustMQ这样的项目，我深刻体会到这一点。我们要做到微秒级延迟，要支持百万级连接，要保证生产环境的绝对稳定。这些目标，靠AI生成的代码是达不到的。必须手撸核心代码，必须深入到CPU缓存、内存对齐、锁竞争这些细节，必须在生产环境反复验证和优化。

有一次，AI生成了一段看起来没问题的代码。功能正确，测试通过。但我仔细看了看，发现在高并发下会有lock contention。改用lock-free数据结构之后，性能提升了40%。这种优化，AI做不到，必须要对并发机制有深刻理解的人才能看出来。

基础软件的开发，对工程师的要求就是更高。需要深厚的底层知识、丰富的实战经验、精湛的编程技艺。这些能力不是AI能给的，也不是短期能速成的。需要多年的积累，需要持续的练习，需要保持在一线。

我常常想，十年后的基础软件领域，会是什么样的竞争格局？我认为会是一小群真正有硬功夫的工程师，主导这个领域。他们能手撸高性能代码，能优化到极致，能设计优雅的架构，能解决复杂的问题。AI让他们效率更高，但核心能力还是他们自己的。

而那些只会用AI的人，可能连进入这个领域的门槛都够不到。

## 未来属于谁

AI会让工程师的分化更加明显。

一部分工程师会因为AI变得更强。他们保持手撸核心代码的能力，保持对底层的深刻理解，保持在一线解决实际问题。同时善用AI提升效率，让AI处理重复劳动，自己专注在最有价值的工作上。这些人的产出可能是以前的两三倍，解决问题的能力更强，技术判断更准确。他们会成为这个行业最稀缺、最值钱的人才。

另一部分工程师会因为AI变得更弱。他们过度依赖AI，不再手撸代码，不再深入底层，能力持续退化。也许他们曾经很优秀，也许他们现在看起来还行，但五年、十年之后，当需要真功夫的时候，他们会发现自己什么都不会。他们的"会用AI"这个技能不再稀缺，他们失去的"硬核能力"才是真正稀缺的。

市场会用脚投票。十年后再回头看，那些坚持手撸代码、保持技术深度、持续在一线的工程师，会成为这个行业最稀缺、最值钱的人才。而那些过度依赖AI、能力退化的工程师，会发现自己越来越难找到好的机会。这是时代的分水岭，也是每个工程师的选择。

选择艰难的路，保持硬功夫，长期看会走得更远。