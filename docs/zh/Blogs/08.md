# 08: RobustMQ 0.2.0 RELEASE：历时两年，我们终于交出了第一份答卷！

> RobustMQ 是基于 Rust 构建的新一代高性能多协议消息队列。愿景是成为新一代云原生与 AI 原生消息基础设施。它不是简单的"又一个消息队列"，而是面向AI时代和云原生需求，对消息队列进行的一次重新思考和设计。

哈哈哈哈，我们终于终于终于可以很骄傲地跟大家说：**RobustMQ 0.2.0 RELEASE 正式发布啦！！！** 🎉🎉🎉

从23年10月敲下第一行代码，到今天正式发布第一个 RELEASE 版本，整整两年时间。两年啊！！！说不激动是假的，说没有压力也是假的。这两年我们重构了好多好多次，推翻了好多好多次，质疑了自己好多好多次，但是我们坚持下来了！

### 两年磨一剑，终于有了第一个正式版本

还记得在上一篇文章《很高兴有机会让你看到不一样的作品》里，我们说预计10月份发布0.2.0版本。虽然稍微晚了一点点（哈哈哈哈，程序员嘛，延期是常态），但是我们做到了！这是我们的第一个 RELEASE 版本，意义重大重大重大！

这两年来，我们一直在问自己：我们到底在做什么？我们做的东西有价值吗？会不会只是在技术自嗨？特别是当看到那么多成熟的消息队列产品时，我们也会怀疑，真的需要"又一个消息队列"吗？

但是今天，当我们看到 RobustMQ 0.2.0 跑起来的那一刻，当我们看到 MQTT 客户端成功连接的那一刻，当我们看到 Dashboard 界面展示出漂亮数据的那一刻...我们知道，这两年的坚持是值得的！

### MQTT 3/4/5 协议完整支持，我们做到了！

在这个版本中，我们完整实现了 **MQTT 3.1、3.1.1、5.0** 三个版本的协议支持！这可不是简单的协议解析哦，我们实现了：

- **完整的 MQTT 协议栈**：从连接建立、订阅发布、到会话管理，每一个细节都严格按照协议标准实现
- **高性能消息路由**：基于 Rust 的零拷贝设计，消息路由性能提升了好多好多倍
- **灵活的 QoS 支持**：QoS 0、1、2 全面支持，保证消息的可靠传输
- **会话持久化**：支持 Clean Session 和持久会话，断线重连不丢消息
- **遗嘱消息**：完整的 Last Will 机制，客户端异常断线也能及时通知

说实话，MQTT 协议看起来简单，但是要做到完全兼容、高性能、稳定可靠，真的不容易。我们参考了好多好多 MQTT Broker 的实现，踩了好多好多坑，重写了好多好多次。但是现在，我们可以很自信地说：RobustMQ 的 MQTT 实现是靠谱的！

### 不只是协议，我们还有完整的生态工具

一个好的消息队列，光有协议支持是不够的。我们还需要好用的管理工具、监控界面、命令行工具。所以在 0.2.0 版本中，我们还提供了：

#### 🎛️ Dashboard 管理界面
我们有一个超级漂亮的 Web 管理界面！可以：
- 实时监控集群状态和性能指标
- 管理 Topic、订阅、客户端连接
- 查看消息流量和系统资源使用情况
- 配置集群参数和存储引擎

界面设计我们花了好多好多心思，既要好看，又要好用。虽然我们都是后端工程师，但是为了用户体验，我们硬着头皮学前端，一点一点调样式。现在看起来还不错哦！

#### 🔧 Command 命令行工具
对于喜欢命令行的同学，我们提供了功能完整的 CLI 工具：
```bash
# 查看集群状态
robustmq-cli cluster status

# 创建 Topic
robustmq-cli topic create --name my-topic --partitions 3

# 查看客户端连接
robustmq-cli client list

# 发送测试消息
robustmq-cli message publish --topic test --payload "Hello RobustMQ!"
```

命令行工具支持所有的管理操作，而且输出格式友好，支持 JSON、表格等多种格式。运维同学应该会喜欢的！

#### 🌐 HTTP API 接口
我们还提供了完整的 RESTful API，方便集成到现有的运维系统中：
```bash
# 获取集群信息
GET /api/v1/cluster/info

# 创建 Topic
POST /api/v1/topics

# 查看消息统计
GET /api/v1/metrics/messages
```

API 文档我们也写得很详细，有完整的请求示例和响应格式说明。

### 架构设计终于稳定了！

这两年最大的收获，其实是我们终于把整体架构设计稳定下来了。还记得我们在《技术设计理念综述》里提到的六个特点吗：高性能、Serverless、插件式存储、极简高内聚架构、计算/存储/调度分离、多协议。

在 0.2.0 版本中，这些设计理念都得到了很好的体现：

#### 🚀 高性能架构
- **基于 Rust 的零拷贝设计**：消息处理全程无内存拷贝，性能提升显著
- **异步 I/O 模型**：基于 Tokio 的高并发处理，单机可支持百万级连接
- **智能消息路由**：高效的订阅匹配算法，路由性能线性扩展

#### ☁️ 云原生架构
- **存算分离设计**：计算节点无状态，可以快速弹性扩缩容
- **插件化存储**：支持内存、本地存储、对象存储等多种存储引擎
- **容器友好**：完美适配 Kubernetes，支持 Helm 部署

#### 🔧 极简架构
- **单二进制部署**：一个文件就能启动完整集群，无外部依赖
- **内置元数据管理**：基于 Raft 的分布式一致性，不依赖 ZooKeeper
- **自动故障恢复**：节点故障自动检测和恢复，运维成本低

### 这只是开始，未来还有好多好多计划

虽然 0.2.0 是我们的第一个 RELEASE 版本，但这只是开始！我们还有好多好多激动人心的计划：

#### 📋 短期计划（接下来几个月）
- **Kafka 协议支持**：让 Kafka 客户端可以无缝迁移到 RobustMQ
- **性能优化**：进一步提升吞吐量和降低延迟
- **监控增强**：更丰富的指标和告警功能
- **文档完善**：更详细的使用指南和最佳实践

#### 🎯 中期计划（明年上半年）
- **AMQP 协议支持**：兼容 RabbitMQ 生态
- **流处理能力**：支持消息流的实时处理
- **多租户支持**：企业级的权限和资源隔离
- **高可用增强**：跨地域部署和灾备能力

#### 🌟 长期愿景
- **AI 原生支持**：为 AI 应用场景优化的消息处理能力
- **边缘计算**：支持边缘节点的轻量级部署
- **生态建设**：丰富的客户端 SDK 和集成工具

### 感谢每一个关注我们的人

说到这里，真的要感谢好多好多人：

- **核心开发团队**：这两年一起熬夜写代码、一起讨论架构、一起解决 Bug 的小伙伴们
- **社区贡献者**：提交 PR、报告 Bug、完善文档的每一位贡献者
- **早期用户**：愿意尝试我们产品、给我们反馈的勇敢的朋友们
- **关注者们**：GitHub 上点 Star、微信群里讨论、公众号里留言的每一个人

特别是我们的微信群，从最开始的几个人，到现在的 300+ 人，大家的每一条消息、每一个建议、每一次鼓励，都是我们坚持下去的动力！

### 来试试吧，我们等你的反馈！

说了这么多，最重要的是：**快来试试 RobustMQ 0.2.0 吧！**

#### 🚀 快速开始
```bash
# 下载二进制包
wget https://github.com/robustmq/robustmq/releases/download/v0.2.0/robustmq-0.2.0-linux-amd64.tar.gz

# 解压运行
tar -xzf robustmq-0.2.0-linux-amd64.tar.gz
cd robustmq-0.2.0-linux-amd64
./bin/robust-server

# 或者使用 Docker
docker run -d --name robustmq -p 1883:1883 -p 8080:8080 robustmq/robustmq:0.2.0
```

#### 🔗 相关链接
- **GitHub**: https://github.com/robustmq/robustmq
- **官网**: https://robustmq.com
- **文档**: https://robustmq.com/docs
- **Dashboard**: http://localhost:8080 (启动后访问)

#### 📱 加入我们
- **微信群**: 扫描官网二维码加入技术讨论群
- **GitHub Discussions**: 参与项目讨论和规划
- **贡献代码**: 我们超级欢迎任何形式的贡献！

### 最后想说的话

两年前，当我们决定用 Rust 重新实现一个消息队列时，很多人觉得我们疯了。"又一个消息队列？""Kafka 不够好吗？""你们能做得比 Pulsar 更好？"

今天，我们用 RobustMQ 0.2.0 给出了我们的答案。虽然还不完美，虽然还有好多好多功能要实现，但是我们证明了：**用 Rust 可以做出一个不一样的消息队列！**

我们不是在造轮子，我们是在造一个更好的轮子。一个更快、更稳定、更灵活、更适合云原生时代的轮子。

这两年的路走得不容易，但是我们很享受这个过程。每一行代码、每一次重构、每一个 Bug 修复，都让我们离目标更近一步。

**RobustMQ 0.2.0，这是我们交出的第一份答卷。**

虽然还不是满分，但是我们会继续努力，继续优化，继续创新。我们相信，总有一天，当大家谈到消息队列的时候，会说：RabbitMQ -> Kafka -> RocketMQ -> Pulsar -> **RobustMQ**。

最后的最后，还是那句话：**很高兴有机会让你看到不一样的作品！**

希望大家都能试试 RobustMQ 0.2.0，给我们反馈，和我们一起把它变得更好更好更好！

阳光、快乐、自由，希望大家都很好很好很好很好的呀~~~

---

**RobustMQ 团队**  
2025年9月29日
