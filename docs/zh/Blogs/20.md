# RobustMQ：从内核开始，重新定义消息平台

今天看到IBM以110亿美元收购Confluent的新闻，说实话，第一反应是有点意外的。在这个AI概念满天飞的时代，消息队列这种传统的基础软件，既没有大模型的性感，也没有应用软件的即时反馈，似乎早就不是聚光灯下的主角了。

过去几个月，确实有很多人问我：现在已经有Kafka、EMQX、RabbitMQ这些成熟的产品，市场格局基本定了，为什么还要做RobustMQ？你们凭什么认为能做得更好？

但今天这个新闻让我想：也许我们真的在做一件对的事情，至少方向应该没错。

## 为什么要从头开始

过去几个月，很多人问我：现在已经有Kafka、EMQX、RabbitMQ这些成熟的产品，为什么还要做RobustMQ？你们凭什么认为能做得更好？

我的答案很简单：**要超越，必须从头来**。

现在很多项目都在做优化：Redpanda用C++重写Kafka，追求更好的性能；一些项目在Kafka基础上加功能，扩展使用场景。这些都是有价值的改进。但我们坚信，**真正的差异性和竞争力，必须从最底层、最内核的地方开始构建**。只有从头设计，才能做出真正不一样的东西。

Kafka是十几年前设计的，那时候还没有云原生的概念，还没有Rust这样的系统语言，还没有存算分离的架构思想。EMQX用Erlang实现，虽然在IoT场景表现很好，但架构上已经很难支持多协议统一。RabbitMQ更是二十年前的产物，受限于当时的技术栈和设计理念。

这些产品都很优秀，都在它们的时代解决了关键问题。但时代在变，技术在进步，需求在演化。如果我们只是在现有基础上修修补补，在别人的架构上做优化，永远无法实现真正意义上的超越。增量改进可以做得更好，但做不到本质不同。

所以我们选择从内核开始，完全重新构建。用Rust而不是Java或Erlang，因为我们需要零GC的性能和内存安全的保障。用存算分离而不是传统的一体化架构，因为云原生时代需要真正的弹性伸缩。设计协议无关的统一内核，而不是为单一协议优化，因为我们相信未来需要的是统一的消息平台，而不是多套割裂的系统。

这条路很难，也很慢。从零开始意味着每一行代码都要自己写，每一个坑都要自己踩，每一个细节都要反复打磨。但我们相信，只有这样，才能在最底层、最核心的地方建立真正的差异性。只有内核足够强大、足够不同，上层的协议和场景才能真正有竞争力。

这是我们的选择，也是我们的坚持。

## 一个内核，多种可能

RobustMQ的核心设计理念是"统一内核，多协议适配"。

我们在内核层实现了高性能的消息路由引擎、存算分离的架构、插件化的存储抽象、弹性的调度机制。这些能力是协议无关的、场景无关的。在这个强大内核之上，MQTT、Kafka、AMQP都只是不同的协议适配层，是内核能力的不同表现形式。

这种设计让我们可以"一次构建，多次复用"。花大力气打磨好内核，之后每增加一个协议，只需要开发相应的适配层。更重要的是，所有协议共享同一套底层能力——性能优化、稳定性保障、监控体系，都是统一的。

MQTT是我们选择的第一个协议。不是因为MQTT市场最大，而是因为MQTT能够充分验证内核的各项能力。发布订阅模型、QoS保障、会话管理、海量连接处理，这些都需要内核提供强大的支持。如果MQTT能做好，说明内核是稳定可靠的。

我们给自己定的标准是：**一个协议做到100%，才启动下一个**。不是60%够用了就行，不是70%差不多就可以，而是100%的功能完整、性能领先、稳定可靠。这个标准看起来很高，但这是对用户负责，也是对技术负责。

第一张名片决定了别人对你的印象。如果MQTT只做到70%，用户不会相信我们能把Kafka做到100%。只有把第一个协议做到极致，才能赢得信任，才能证明我们的内核设计是成功的。

这个过程会很慢。可能别人两年支持了五个协议，而我们两年只完成了一个协议。但我们的一个协议是100分，而他们的五个协议可能都是60分。我相信用户会用脚投票。


## 技术的选择

做基础软件，技术选型至关重要。

选择Rust，是因为它提供了接近C++的性能，同时保证了内存安全。消息队列对性能的要求极高，每一微秒的延迟都要斤斤计较。Rust的零GC特性让延迟更加稳定，所有权系统让并发更加安全。这不是为了赶时髦，而是为了做出真正高性能、高可靠的系统。

选择存算分离，是因为云原生时代需要真正的弹性。计算层无状态，可以秒级启停；存储层独立，可以根据数据量灵活扩展。这种架构让RobustMQ天然具备Serverless能力，适应云环境的动态变化。

选择多协议统一，是因为我们相信这是未来的方向。企业不应该需要部署EMQX、Kafka、RabbitMQ三套系统，而是一套RobustMQ就能解决从IoT到流处理到微服务通信的所有需求。这个愿景很大，但我们会一步步实现。

每一个技术决策，都是在为长期布局。我们不追求短期的便利，而是追求长期的正确。


## 十年的视角

看Confluent的发展历程，11年从创立到被收购，验证了一个道理：**优秀的基础软件需要时间**。

我们给自己的时间也是10年。前5年专注技术打磨，一个协议一个协议地做到极致，一个场景一个场景地深入验证。后5年考虑规模化和商业化，当技术足够成熟、用户足够多的时候，商业价值会自然显现。

这不是逃避商业化，而是相信技术的力量。如果技术真的好，用户会来；如果用户真的多，商业机会就在那里。Confluent的110亿美元估值，不是因为他们会做生意，而是因为Kafka确实解决了实际问题，被广泛使用。

我们也相信这一点。如果RobustMQ的内核真的足够强大，如果我们的多协议统一确实简化了企业的技术栈，如果我们在AI等场景确实提供了独特的价值，那么用户会选择我们，市场会认可我们。

但这需要时间，需要耐心，需要坚持。

## 抬头看天，低头走路

有人说我们的愿景太大——"下一代统一消息平台"，要支持所有协议、所有场景。确实很大，但我们相信这是正确的方向。

云原生时代，企业需要的是更简单、更统一的基础设施，而不是更多、更分散的系统。消息基础设施的统一，就像容器编排被Kubernetes统一一样，是技术发展的必然趋势。

但我们也很清醒。愿景归愿景，执行要脚踏实地。当下我们的重点很明确：把MQTT做到100%，用MQTT验证内核的稳定性和可靠性。同时探索AI场景，验证内核的通用性和性能。一步一个脚印，不急不躁。

抬头看天，知道自己要去哪里；低头走路，知道脚下的每一步怎么走。这是我们的节奏。

## 可能在做对的事

今天的这个新闻，让我更加确信我们在做对的事情。

消息队列这个赛道，有110亿美元的价值验证。AI时代对数据基础设施的需求，正在快速增长。统一平台的理念，符合技术演进的趋势。从内核开始构建差异性，是真正能够超越现有产品的路径。

当然，路还很长。MQTT协议还在开发中，内核还在不断优化，社区还在初步建设，距离Confluent的成熟度还有巨大的差距。但我们不着急。

Confluent用了11年，Linux用了30年，PostgreSQL也用了20多年。伟大的基础软件需要时间，需要持续的投入，需要长期的积累。我们也给自己10年的时间。

这10年里，我们会一行行手撸核心代码，一个个解决技术难题，一步步验证设计理念。我们会保持开放的心态，听取社区的反馈，根据实际情况调整策略。我们会坚持技术的纯粹性，不为短期利益妥协架构的优雅。

也许10年后，RobustMQ会成为下一个Confluent，被某个大公司以更高的价格收购。也许会成为一个成功的开源项目，像PostgreSQL一样被广泛使用。也许会成为Apache的顶级项目，在消息队列领域占有一席之地。

但这些都是后话。当下，我们只是想脚踏实地地做好技术，写好每一行代码，解决每一个问题，服务好每一个用户。

如果这件事是对的，时间会给出答案。

---

*RobustMQ正在构建下一代统一消息平台。如果你认同我们的理念，欢迎关注我们的GitHub，加入我们的Discord社区，一起参与这个长期的技术探索。*