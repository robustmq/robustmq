# 存储层 Storage Adapter 架构

## 设计理念

RobustMQ 存储层采用 **可插拔架构**，集群支持多种底层存储引擎，业务可以根据不同需求灵活选择存储引擎。

**核心实现**：通过 Storage Adapter 层实现插件化存储引擎
- 使用 Trait 定义底层存储引擎必须具备的能力
- 任何实现了这些能力的存储系统都可以作为 RobustMQ 的底层存储引擎
- 支持运行时动态选择和切换存储引擎


---

## 支持的存储引擎

存储引擎分为 **本地存储** 和 **远程存储** 两大类：

### 存储引擎对比

| 存储引擎 | 类型 | 部署模式 | 支持状态 | 适用场景 |
|---------|------|---------|---------|---------|
| **Memory** | 本地存储 | 仅单机 | ✅ 已支持 | 开发测试、临时数据、高速缓存 |
| **RocksDB** | 本地存储 | 仅单机 | ✅ 已支持 | 开发测试、持久化存储 |
| **Local File** | 本地存储 | 仅单机 | ❌ 未支持 | 开发测试、持久化存储 |
| **Journal Engine** | 远程存储 | 集群/单机 | 🚧 开发中 | 低延时、高吞吐、持久化<br>**（默认存储引擎）** |
| **MySQL** | 远程存储 | 集群/单机 | ✅ 已支持 | 消息数据需存储到 MySQL 的场景 |
| **Redis** | 远程存储 | 集群/单机 | ❌ 规划中 | 消息数据需存储到 Redis 的场景 |
| **MinIO** | 远程存储 | 集群/单机 | ❌ 规划中 | 本地部署、高吞吐、低成本、大规模数据 |
| **Object Storage (S3)** | 远程存储 | 集群/单机 | ❌ 规划中 | 云部署、高吞吐、低成本、大规模数据 |

### 本地存储 vs 远程存储

| 特性 | 本地存储 | 远程存储 |
|------|---------|---------|
| **适用环境** | 单机、测试模式 | 集群模式、生产环境 |
| **容灾能力** | ❌ 无多节点、多副本容灾 | ✅ 分布式、多副本、高可靠 |
| **数据持久化** | 部分支持（RocksDB、File） | ✅ 完全支持 |
| **默认引擎** | - | Journal Engine |
| **典型场景** | 开发调试、快速验证 | 高可靠、分布式、持久化场景 |

> **注意**：各存储引擎的适配场景会随着开发进度不断调整优化。

---

## Storage Adapter 架构

### 架构图
![img](../../images/storage-adapter.png)

### 核心能力定义

Storage Adapter 是 Broker 中的一个代码模块，通过 Trait 定义底层存储引擎必须具备的能力：

| 能力类别 | 功能描述 | 具体能力 |
|---------|---------|---------|
| **Shard 管理** | 分片生命周期管理 | • 创建分片<br>• 列出分片<br>• 删除分片 |
| **数据写入** | 消息写入能力 | • 单条写入<br>• 批量写入<br>• 返回 offset |
| **多维度查询** | 灵活的数据读取 | • 按 offset 读取<br>• 按 key 读取<br>• 按 tag 读取<br>• 按时间戳查找 offset |
| **消费组管理** | 消费进度管理 | • 提交消费 offset<br>• 获取消费 offset |
| **消息过期** | 数据生命周期管理 | • 基于时间的数据淘汰<br>• 基于大小的数据淘汰 |

**核心原则**：只要实现了上述所有能力，任何存储系统都可以作为 RobustMQ 的底层存储引擎。


---

## 如何使用

### 配置方式

通过启动配置选择存储引擎。配置示例：

```json
"message_storage": {
  "storage_type": "Memory",
  "journal_config": null,
  "memory_config": null,
  "minio_config": null,
  "mysql_config": null,
  "rocksdb_config": null,
  "s3_config": null
}
```

**配置说明**：
- `storage_type`: 指定存储引擎类型（如 `Memory`、`RocksDB`、`MySQL` 等）
- 其他 `*_config`: 各存储引擎的具体配置项

### 多引擎支持

| 特性 | 说明 |
|------|------|
| **集群级配置** | 可配置 1 个或 N 个存储引擎 |
| **默认引擎** | 集群启动时配置默认存储引擎 |
| **Topic 级选择** | 创建 Topic 时可指定存储引擎 |
| **灵活存储** | 不同 Topic 可使用不同存储引擎 |
| **默认行为** | 未指定时使用集群默认存储引擎 |

### 存储引擎变更

当需要变更 Topic 的存储引擎时，必须手动指定变更策略：

| 策略 | 说明 | 适用场景 |
|------|------|---------|
| **丢弃数据** | 直接切换，不保留旧数据 | 测试环境、可丢弃的历史数据 |
| **搬迁数据** | 将旧引擎数据迁移到新引擎 | 生产环境、重要历史数据 |

> **重要提示**：存储引擎变更是重要操作，请谨慎选择变更策略，确保数据安全。


---

## Shard 概念

### 设计背景

不同消息队列系统的存储单位各不相同，但本质上都采用 **Append Only**（只追加）模型。

### 存储单位对比

| 消息队列系统 | 组织层级 | 存储单位 | 存储模型 | RobustMQ 抽象 |
|------------|---------|---------|---------|--------------|
| MQTT | Topic | Topic | Append Only | **Shard** |
| AMQP | Queue | Queue | Append Only | **Shard** |
| Kafka | Topic → Partition | Partition | Append Only | **Shard** |
| RocketMQ | Topic → MessageQueue | MessageQueue | Append Only | **Shard** |
| Pulsar | Topic → Partition | Partition | Append Only | **Shard** |

### Shard 统一抽象

**为什么需要 Shard？**

Storage Adapter 引入 **Shard** 概念来统一抽象各个不同协议的消息数据存储，实现：
- ✅ 屏蔽不同消息系统的存储差异
- ✅ 提供统一的存储接口和语义
- ✅ 简化存储引擎的实现复杂度

**Shard 是什么？**

Shard 是 RobustMQ 的统一数据存储组织单位：
- 类似于 Kafka 的 **Partition**
- 类似于 RocketMQ 的 **MessageQueue**
- 类似于 Pulsar 的 **Partition**

**Shard 的能力**
- 支持 **分布式** 部署
- 支持 **多副本** 存储
- 提供 **Append Only** 写入模型
- 支持多维度查询（offset、key、tag、timestamp）

通过 Shard 抽象，RobustMQ 能够以统一的方式处理 MQTT、AMQP、Kafka 等多种协议的消息存储需求。

