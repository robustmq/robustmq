# 存储层系统架构
RobustMQ 存储层被设计成可插拔的架构。也就是说，集群支持多种底层存储引擎，业务可以根据不同的需求去选择不同的存储引擎。

从规划来看，存储引擎分为本地存储和远程存储两类，本地存储为：Memory、RocksDB、Local File 三种类型，远程存储主要包括Journal Engine、MySQL、Redis、MinIO、Object Storage(S3)等。

来看下面表格：

| 存储引擎 | 类型 | 部署模式 | 支持状态 | 适用场景 |
|---------|------|---------|---------|---------|
| Memory | 本地存储 | 仅单机 | ✅ 已支持 | 开发测试、临时数据、高速缓存 |
| RocksDB | 本地存储 | 仅单机 | ✅ 已支持 | 开发测试、需要持久化 |
| Local File | 本地存储 | 仅单机 | ❌ 未支持 | 日志归档、冷数据存储、顺序读写 |
| Journal Engine | 远程存储 | 集群/单机 | 🚧 支持中 | 高吞吐分布式场景、消息队列核心存储 |
| MySQL | 远程存储 | 集群/单机 | ✅ 已支持 | |
| Redis | 远程存储 | 集群/单机 | ❌ 未支持 |  |
| MinIO | 远程存储 | 集群/单机 | ❌ 未支持 | |
| Object Storage(S3) | 远程存储 | 集群/单机 | ❌ 未支持 | 海量数据归档、成本优化、冷热分离 |

可以看到，上面支持的存储类型有点多。简要说一下各种类型的区别。本地存储一般用在单机模式或测试模式。远程存储用在集群模式，适配各种高可靠、持久化场景。
> 说实话，当前主要希望支持多种不同的存储引擎。长期来看，各种存储引擎适配的场景是会调整的。这块后续的场景描述应该会改动比较大。
> 

## 存储适配层架构图
![img](../../images/storage-adapter.png)

如上图所示，Storage Adapter 是 Broker 中的一个代码模块。它通过Trait 来定义底层引擎需要具备如下能力：
1. Shard 管理：创建、列出、删除分片
2. 数据写入：单条/批量写入，返回 offset
3. 多维度查询：
   1. 按 offset 读取
   2. 按 key 读取
   3. 按 tag 读取
   4. 按时间戳查找 offset
4. 消费组管理：提交和获取消费 offset
5. 消息过期：基于时间或大小的数据淘汰

也就是说，只要在Storage Adapter中实现对应的这些能力，就可以作为RobustMQ底层的存储引擎。


## 如何使用？
它通过启动时配置的不同，使用不同的存储引擎。配置如下图所示：
```
    "message_storage": {
        "storage_type": "memory",
        "journal_addr": "",
        "mysql_addr": "",
        "rocksdb_data_path": "",
        "rocksdb_max_open_files": null
    }
```
上面的配置 storage_type = memory，则表示数据存储在内存中。在集群启动的时候，可以配置默认的存储引擎，存储引擎可以配置1个或者N个。然后在创建Topic时允许你指定这个Topic的存储引擎，也就是每个Topic可以根据需要选择将数据存储在不同的存储引擎中。如果不指定存储引擎，则会存储到集群配置的默认的存储引擎中。

> 需要注意的是，如果需要变更Topic的存储引擎，则需要手动指定变更策略。策略有丢弃数据和搬迁数据两种选项。顾名思义，就是指定是否把老的引擎的数据搬迁到新的集群。



## Shard 
因为不同的消息队列的存储的单位是不一样的，但是本质上底层逻辑都是一样的，都是 Append Only 模型。如下所示：
1. MQTT：以topic为单位存储数据。
2. AMQP: 以Queue 为单位存储数据。
3. Kafka：以Topic组织多个Partition，以Partition为单位存储数据
4. RocketMQ：以 Topic 组织多个 MessageQueue，以 MessageQueue 为单位存储数据。
5. Pulsar：以Topic组织多个Partition，以Partition为单位存储数据

我们以 Shard 为单位存储数据。Shard 是一个数据存储的组织单位

## Storage Adapter


## 内存存储


## RocksDB存储

## Offset 记录
