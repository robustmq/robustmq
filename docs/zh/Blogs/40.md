---
layout: doc
sidebar: false
aside: false
pageClass: blog-post-page
---

# AI 时代的基础软件开发：精力分配的改变

开发 RobustMQ 这一年多，AI 辅助编程成为了我工作流程的重要部分。在不断和 AI 配合 coding 的过程中，我最深的感受是：**精力分配发生了根本改变**。

以前的精力，大量消耗在重复性检查、低级 bug、机械性工作上。现在这些可以交给 AI，精力可以集中在真正重要的事情上：架构设计、性能优化、核心功能。这个改变带来的提速，比单纯的"写代码快了"要大得多。

## 精力被什么消耗

开发基础软件，很多人以为主要时间在写新功能。但实际上，大量时间花在：

**修低级 bug**：边界条件没考虑、错误处理不完整、某个函数可能返回 None 但没处理、某个边界条件下会 panic。这些问题单个看不难，但数量多、分散、琐碎。

**重复性检查**：review 代码，检查是否有内存泄漏、是否有并发安全问题、是否有性能隐患。每次都要仔细看，但人会累、会走神，特别是 review 几千行代码时，后面就不如前面仔细了。

**重构历史债务**：早期为了赶进度写得不够好的代码，后期要花时间重构。而且一个地方的问题，可能会引发连锁反应，改一个地方，其他地方也要改。

**机械性工作**：写测试、写文档、写 issue、格式化代码。这些都重要，但都机械、重复、消耗精力。

看 Kafka 的 release notes，大量版本主要在修 bug、重构模块、优化历史问题。Pulsar 更明显，经常修各种边界情况的问题、并发死锁、数据不一致。这些都是精力消耗的大头。

## AI 改变了什么

AI 最大的价值不是"帮我写代码"，而是**承担了大量重复性检查工作**。

我写完代码，立即让 AI 检查。它会指出边界条件遗漏、错误处理不当、可能的 panic 点、潜在的并发问题。这些低级问题在早期就被消灭了，不会累积到后期成为技术债。

更重要的是，AI 的检查是稳定的。不会"今天状态好就仔细看，明天累了就马虎"，每次都是同样的标准。该发现的问题不会因为人的疲劳或疏忽而漏掉。

我让 AI 生成测试用例，它会覆盖很多场景，快速建立基础测试覆盖。虽然我还要检查关键场景是否遗漏，但基础工作量已经大幅减少。

我让 AI 帮我写文档、格式化代码。这些机械性工作，AI 处理得又快又规范。我只需要把核心想法讲清楚，AI 就能整理成规范的输出。

## 一个持续实践的例子：自动创建 issue

最近我发现一个特别好用的技能。以前写 issue 是个负担，想清楚了要做什么，但总觉得写 issue 很麻烦，结果很多想法就懒得写。现在我的做法是：把想法说给 AI 听，让它理解代码上下文，它就能创建一个完整规范的 issue。

这极大地释放了生产力。以前因为"写 issue 麻烦"而不记录，现在随时想到什么就能立即记录。项目的 issue 多了、规范了，对社区建设帮助很大。而且所有想法都能保留下来，不会因为"懒得写"而流失。这个技能是在不断使用 AI 的过程中摸索出来的。

## 精力分配的改变

以前我的大量时间花在修 bug、重构历史问题、重复性检查、机械性工作上，真正用来做架构设计、核心功能、性能优化的时间很少。现在这个比例发生了根本改变：AI 承担了检查和机械性工作，我可以把大部分精力集中在推动项目前进的事情上。

这不只是快慢的问题，而是精力的质量不同。以前花大量精力修 bug，这些精力是被迫消耗的、被动的、没有积累的。现在大部分精力做架构、优化、核心功能，这些精力是主动投入的、有积累的。每一次优化、每一个功能，都让项目变得更好。

人的精力不只是时间，更是状态。早上状态好可以做复杂设计，下午累了只能做重复工作。如果大量时间花在重复工作上，等到要做架构设计时，状态已经不好了。更可怕的是心理负担：你知道应该仔细 review 每一行代码，但你累了、走神了，这种"应该做好但做不到"的心理负担是隐形的消耗。AI 让我可以放下这个负担，把精力保持在核心工作上。

这个改变带来的效果是复利的。精力花在真正推动项目前进的事情上，项目进展更快、方向更清晰、代码质量更高。而代码质量高，后期需要修的 bug 就少，又进一步释放了精力。

## 站在成熟轮子的肩膀上

精力分配的改变，不只是 AI，还有成熟组件的帮助。

用 RocksDB 而不是自己实现存储，省了几万行代码，也省了大量精力。不需要花精力调试文件管理、索引维护、crash 恢复，这些 Facebook 已经解决了。我可以把精力花在设计 key 的格式、优化配置参数、适配业务逻辑。

用 tokio 而不是自己实现异步，用 io_uring 而不是自己优化 I/O，都是同样的逻辑。把基础能力的精力节省下来，花在真正有差异化的地方。

AI 和成熟组件结合起来，让精力可以更加集中在核心工作上。不需要重复造轮子，不需要被低级问题拖累，可以专注在真正创造价值的地方。

## 这个改变有多大

现在开发基础软件，整体速度会快很多。但更重要的是，这个提速主要来自精力分配的改变，而不是单纯的"写代码快了"。

**快的不是因为 AI 帮我写核心代码。** 而是它做了很多重复性工作：替我检查出了很多低级问题，完成了大量测试用例覆盖，处理了各种机械性任务。这些工作以前占用了大量精力，现在被 AI 承担了。

如果只是写代码快了，但还是花大量精力修 bug、做重复检查，那总体提速有限。

但如果精力分配改变了，从少量时间做核心工作，提升到大量时间做核心工作，那提速会非常明显。因为核心工作推动项目前进，带来的是指数级的改变，而不是线性的。

这就是精力分配改变的力量。

## 但核心还是要自己把控

说了这么多 AI 的好处，但我要强调：核心还是要自己把控。

AI 可以帮我检查、测试、格式化、写 issue，但架构设计、核心代码、关键判断，必须自己做。不是 AI 做不了，而是即使它能做，我也不会让它做。因为这些是项目的灵魂，交给 AI 就失去了掌控。

精力分配的改变，是让我可以把更多精力花在这些核心事情上，而不是让 AI 替我做这些事情。

这是一个重要的区别。不是"AI 替我做了核心工作"，而是"AI 承担了重复工作，让我可以集中精力做核心工作"。

## 总结

AI 时代的基础软件开发，最大的改变不是"写代码快了"，而是**精力分配改变了**。

从被低级问题消耗精力，变成可以集中精力做核心工作。从被重复性工作拖累，变成可以专注在真正推动项目前进的事情上。

这个改变带来的提速，比单纯的"写代码快了"要大得多。因为精力用对地方了，带来的是质量的提升、方向的清晰、项目的进步。

RobustMQ 的开发过程中，我深刻体会到了这一点。AI 让我可以把精力集中在架构设计、性能优化、核心功能上，而不是被低级 bug、重复检查、机械工作消耗。这是 AI 给我最大的价值。

精力是有限的，用对地方，才能走得更远。
